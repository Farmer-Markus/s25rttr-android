diff -ruN --binary -x '.*' -x patched s25client/CMakeLists.txt s25client_patched/CMakeLists.txt
--- s25client/CMakeLists.txt	2025-06-14 12:48:51.353857914 +0200
+++ s25client_patched/CMakeLists.txt	2025-06-14 12:55:20.555283964 +0200
@@ -22,9 +22,17 @@
     message(STATUS "Used Toolchain definition file '${CMAKE_TOOLCHAIN_FILE}'")
 endif()
 
-list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules" "${CMAKE_SOURCE_DIR}/external/libutil/cmake")
-if(CMAKE_VERSION VERSION_LESS 3.14)
-    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/external/libutil/cmake/cmake_3.14")
+
+if(ANDROID)
+    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/src/s25client/cmake/Modules" "${CMAKE_SOURCE_DIR}/src/s25client/external/libutil/cmake")
+    if(CMAKE_VERSION VERSION_LESS 3.14)
+        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/src/s25client/external/libutil/cmake/cmake_3.14")
+    endif()
+else()
+    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules" "${CMAKE_SOURCE_DIR}/external/libutil/cmake")
+    if(CMAKE_VERSION VERSION_LESS 3.14)
+        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/external/libutil/cmake/cmake_3.14")
+    endif()
 endif()
 
 include(EnableCCache)
@@ -274,6 +282,10 @@
     else()
         message(FATAL_ERROR "Unknown architecture for sizeof(void*)=${CMAKE_SIZEOF_VOID_P}")
     endif()
+elseif(ANDROID)
+    message(STATUS "Unofficial build with processor arch: ${CMAKE_SYSTEM_PROCESSOR}. Skipping release scripts and updater.")
+    unset(PLATFORM_ARCH)
+    set(RTTR_BUILD_UPDATER OFF CACHE INTERNAL "Disabled")
 else()
     if(${CMAKE_SYSTEM_PROCESSOR} MATCHES "i.86")
         set(PLATFORM_ARCH "i386")
@@ -300,7 +312,12 @@
     set(BOOST_ROOT ${rttrContribBoostDir} CACHE PATH "Path to find boost at")
 endif()
 
-set(BoostPackages filesystem iostreams locale program_options)
+if(ANDROID)
+    set(BoostPackages filesystem iostreams locale system thread program_options)
+else()
+    set(BoostPackages filesystem iostreams locale program_options)
+endif()
+
 if(BUILD_TESTING)
     # Avoid having to search for this in all tests speeding up configure
     list(APPEND BoostPackages unit_test_framework)
diff -ruN --binary -x '.*' -x patched s25client/data/RTTR/texte/de/keyboardlayout.txt s25client_patched/data/RTTR/texte/de/keyboardlayout.txt
--- s25client/data/RTTR/texte/de/keyboardlayout.txt	2025-06-14 12:47:10.972187978 +0200
+++ s25client_patched/data/RTTR/texte/de/keyboardlayout.txt	2025-06-14 12:55:20.555917420 +0200
@@ -2,6 +2,19 @@
 ------------------------------------------------------------------------
 Globale Tastaturbelegung im Spiel:
 
+---------
+Android
+---------
+
+-Mit dem Finger über die Karte wischen, um sie zu verschieben
+
+-Einmal tippen wird wie ein Linksklick der Maus gewertet
+
+-Mit 2 Fingern zoomen
+
+-Doppelt tippen, um Fenster schneller zu schließen
+
+
 Eingeklammerte Belegungen funktionieren noch nicht.
 
 P:.................... Pause
diff -ruN --binary -x '.*' -x patched s25client/data/RTTR/texte/de/readme.txt s25client_patched/data/RTTR/texte/de/readme.txt
--- s25client/data/RTTR/texte/de/readme.txt	2025-06-14 12:47:10.972241321 +0200
+++ s25client_patched/data/RTTR/texte/de/readme.txt	2025-06-14 12:55:20.556387690 +0200
@@ -12,6 +12,7 @@
   2. Multiplayer-Spiele
   3. Replays
   4. Optionen
+  5. Android
 D. Abstürze und Fehler
 E. Übersicht: Updates und Änderungen
 
@@ -206,6 +207,47 @@
 
     Die Einstellungen im Optionsmenü sollten so weit selbsterklärend sein.
 
+  6. Android
+
+    Diese android version von RTTR ist nicht offiziell und ich als
+    Entwickler dieser Portierung stehe nicht mit den
+    Entwicklern von RTTR in Verbindung!
+
+    Es musste einiges an RTTR verändert werden, damit es auf Android
+    funktioniert. Wichtige Änderungen werde ich hier aufzählen.
+
+    a) Bildschirmausrichtung
+       Die Bildschirmausrichtung hängt von der Ausrichtung des
+       Handys ab.
+       Um RTTR automatisch im Querformat zu starten, muss
+       der Vollbildmodus in den Einstellungen aktiviert
+       und die App einmal neu gestartet werden.
+
+    b) Steuerung
+       Wenn sie eine externe Maus benutzen, sollte die Steuerung
+       exakt gleich wie auf dem Computer funktionieren.
+
+       Die Touch Steuerung funktioniert ähnlich wie bei den meisten
+       Handy spielen:
+
+       -Mit dem Finger über die Karte wischen, um sie zu verschieben.
+
+       -Einmal tippen wird wie ein Linksklick der Maus gewertet.
+
+       -Mit 2 Fingern zoomen.
+
+       -Doppelt tippen, um Fenster schneller zu schließen.
+
+    c) Texteingaben
+       Um Text in ein Textfeld einzugeben einfach darauf tippen und die
+       eingebaute system Tastatur sollte erscheinen.(noch nicht verfügbar)
+
+    d) Multiplayer
+       Der Multiplayer funktioniert zurzeit leider noch nicht.
+       Es ist zwar möglich, im selben Netzwerk zu spielen, wenn ein Spieler 
+       am Handy den Server hostet und andere Spieler über den PC beitreten.
+       Ich werde jedoch versuchen, den Multiplayer vollständig
+       zu implementieren.
 
 --------------------------------------------------------------------------------
 
diff -ruN --binary -x '.*' -x patched s25client/data/RTTR/texte/keyboardlayout.txt s25client_patched/data/RTTR/texte/keyboardlayout.txt
--- s25client/data/RTTR/texte/keyboardlayout.txt	2025-06-14 12:47:10.972241321 +0200
+++ s25client_patched/data/RTTR/texte/keyboardlayout.txt	2025-06-14 12:55:20.556864209 +0200
@@ -2,6 +2,19 @@
 ------------------------------------------------------------------------
 Global keyboard layout in game:
 
+---------
+Android
+---------
+
+-Swipe across the map with your finger to move it
+
+-Single tap is treated as a left mouse click
+
+-Zoom with two fingers
+
+-Double tap to close windows faster
+
+
 Bracketed keys do not work yet.
 
 P:.................... Pause
diff -ruN --binary -x '.*' -x patched s25client/data/RTTR/texte/readme.txt s25client_patched/data/RTTR/texte/readme.txt
--- s25client/data/RTTR/texte/readme.txt	2025-06-14 12:47:10.972241321 +0200
+++ s25client_patched/data/RTTR/texte/readme.txt	2025-06-14 12:55:20.557269837 +0200
@@ -12,6 +12,7 @@
   2. Multiplayer game
   3. Replays
   4. Options
+  5. Android
 D. Crash and bugs
 E. Summary: Updates and changelog
 
@@ -195,6 +196,46 @@
 
     The options in the main menu are self-explanatory.
 
+  6. Android
+
+    This Android version of RTTR is not official, and I, as
+    the developer of this port, am not affiliated with the
+    developers of RTTR!
+
+    Several changes had to be made to RTTR in order for it to work
+    on Android. I will list the important changes here.
+
+    a) Screen orientation
+       The screen orientation depends on the orientation of the
+       phone.
+       To automatically start RTTR in landscape mode, you can
+       enable fullscreen mode in the settings
+       and restart the app once.
+
+    b) Controls
+       If you use an external mouse, the controls should work
+       exactly the same as on Pc.
+
+       The touch controls work similarly to most mobile games:
+
+       -Swipe across the map with your finger to move it.
+
+       -Single tap is treated as a left mouse click.
+
+       -Zoom with two fingers.
+
+       -Double tap to close windows faster.
+
+    c) Text input
+       To enter text into a text field, simply tap on it, and the
+       built-in system keyboard should appear. (not yet available)
+
+    d) Multiplayer  
+       Unfortunately, multiplayer does not work yet.
+       It is possible to play in the same network if one player
+       hosts the server on a mobile device and other players join
+       via PC, but I will try to fully implement multiplayer.
+
 --------------------------------------------------------------------------------
 
 D. Crash and bugs
diff -ruN --binary -x '.*' -x patched s25client/external/CMakeLists.txt s25client_patched/external/CMakeLists.txt
--- s25client/external/CMakeLists.txt	2025-06-14 12:48:51.374234508 +0200
+++ s25client_patched/external/CMakeLists.txt	2025-06-14 12:55:20.557724133 +0200
@@ -51,7 +51,11 @@
 add_subdirectory(libsiedler2)
 add_subdirectory(libutil)
 add_subdirectory(mygettext)
-add_subdirectory(s25edit)
+
+if(!ANDROID)
+    add_subdirectory(s25edit)
+endif()
+
 if(RTTR_BUILD_UPDATER)
     add_subdirectory(s25update)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/external/dev-tools/msvc/include/SDL2/SDL_config_macosx.h.orig s25client_patched/external/dev-tools/msvc/include/SDL2/SDL_config_macosx.h.orig
--- s25client/external/dev-tools/msvc/include/SDL2/SDL_config_macosx.h.orig	2025-06-14 12:47:29.535671606 +0200
+++ s25client_patched/external/dev-tools/msvc/include/SDL2/SDL_config_macosx.h.orig	1970-01-01 01:00:00.000000000 +0100
@@ -1,197 +0,0 @@
-/*
-  Simple DirectMedia Layer
-  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-*/
-
-#ifndef SDL_config_macosx_h_
-#define SDL_config_macosx_h_
-#define SDL_config_h_
-
-#include "SDL_platform.h"
-
-/* This gets us MAC_OS_X_VERSION_MIN_REQUIRED... */
-#include <AvailabilityMacros.h>
-
-/* This is a set of defines to configure the SDL features */
-
-#ifdef __LP64__
-    #define SIZEOF_VOIDP 8
-#else
-    #define SIZEOF_VOIDP 4
-#endif
-
-/* Useful headers */
-#define HAVE_ALLOCA_H       1
-#define HAVE_SYS_TYPES_H    1
-#define HAVE_STDIO_H    1
-#define STDC_HEADERS    1
-#define HAVE_STRING_H   1
-#define HAVE_INTTYPES_H 1
-#define HAVE_STDINT_H   1
-#define HAVE_CTYPE_H    1
-#define HAVE_MATH_H 1
-#define HAVE_SIGNAL_H   1
-
-/* C library functions */
-#define HAVE_MALLOC 1
-#define HAVE_CALLOC 1
-#define HAVE_REALLOC    1
-#define HAVE_FREE   1
-#define HAVE_ALLOCA 1
-#define HAVE_GETENV 1
-#define HAVE_SETENV 1
-#define HAVE_PUTENV 1
-#define HAVE_UNSETENV   1
-#define HAVE_QSORT  1
-#define HAVE_ABS    1
-#define HAVE_BCOPY  1
-#define HAVE_MEMSET 1
-#define HAVE_MEMCPY 1
-#define HAVE_MEMMOVE    1
-#define HAVE_MEMCMP 1
-#define HAVE_STRLEN 1
-#define HAVE_STRLCPY    1
-#define HAVE_STRLCAT    1
-#define HAVE_STRDUP 1
-#define HAVE_STRCHR 1
-#define HAVE_STRRCHR    1
-#define HAVE_STRSTR 1
-#define HAVE_STRTOL 1
-#define HAVE_STRTOUL    1
-#define HAVE_STRTOLL    1
-#define HAVE_STRTOULL   1
-#define HAVE_STRTOD 1
-#define HAVE_ATOI   1
-#define HAVE_ATOF   1
-#define HAVE_STRCMP 1
-#define HAVE_STRNCMP    1
-#define HAVE_STRCASECMP 1
-#define HAVE_STRNCASECMP 1
-#define HAVE_VSSCANF 1
-#define HAVE_VSNPRINTF  1
-#define HAVE_CEIL   1
-#define HAVE_COPYSIGN   1
-#define HAVE_COS    1
-#define HAVE_COSF   1
-#define HAVE_FABS   1
-#define HAVE_FLOOR  1
-#define HAVE_LOG    1
-#define HAVE_POW    1
-#define HAVE_SCALBN 1
-#define HAVE_SIN    1
-#define HAVE_SINF   1
-#define HAVE_SQRT   1
-#define HAVE_SQRTF  1
-#define HAVE_TAN    1
-#define HAVE_TANF   1
-#define HAVE_SIGACTION  1
-#define HAVE_SETJMP 1
-#define HAVE_NANOSLEEP  1
-#define HAVE_SYSCONF    1
-#define HAVE_SYSCTLBYNAME 1
-#define HAVE_ATAN 1
-#define HAVE_ATAN2 1
-#define HAVE_ACOS 1
-#define HAVE_ASIN 1
-
-/* Enable various audio drivers */
-#define SDL_AUDIO_DRIVER_COREAUDIO  1
-#define SDL_AUDIO_DRIVER_DISK   1
-#define SDL_AUDIO_DRIVER_DUMMY  1
-
-/* Enable various input drivers */
-#define SDL_JOYSTICK_IOKIT  1
-#define SDL_HAPTIC_IOKIT    1
-
-/* Enable various shared object loading systems */
-#define SDL_LOADSO_DLOPEN   1
-
-/* Enable various threading systems */
-#define SDL_THREAD_PTHREAD  1
-#define SDL_THREAD_PTHREAD_RECURSIVE_MUTEX  1
-
-/* Enable various timer systems */
-#define SDL_TIMER_UNIX  1
-
-/* Enable various video drivers */
-#define SDL_VIDEO_DRIVER_COCOA  1
-#define SDL_VIDEO_DRIVER_DUMMY  1
-#undef SDL_VIDEO_DRIVER_X11
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC "/usr/X11R6/lib/libX11.6.dylib"
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XEXT "/usr/X11R6/lib/libXext.6.dylib"
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XINERAMA "/usr/X11R6/lib/libXinerama.1.dylib"
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XINPUT2 "/usr/X11R6/lib/libXi.6.dylib"
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XRANDR "/usr/X11R6/lib/libXrandr.2.dylib"
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XSS "/usr/X11R6/lib/libXss.1.dylib"
-#define SDL_VIDEO_DRIVER_X11_DYNAMIC_XVIDMODE "/usr/X11R6/lib/libXxf86vm.1.dylib"
-#define SDL_VIDEO_DRIVER_X11_XDBE 1
-#define SDL_VIDEO_DRIVER_X11_XINERAMA 1
-#define SDL_VIDEO_DRIVER_X11_XRANDR 1
-#define SDL_VIDEO_DRIVER_X11_XSCRNSAVER 1
-#define SDL_VIDEO_DRIVER_X11_XSHAPE 1
-#define SDL_VIDEO_DRIVER_X11_XVIDMODE 1
-#define SDL_VIDEO_DRIVER_X11_HAS_XKBKEYCODETOKEYSYM 1
-
-#ifdef MAC_OS_X_VERSION_10_8
-/*
- * No matter the versions targeted, this is the 10.8 or later SDK, so you have
- *  to use the external Xquartz, which is a more modern Xlib. Previous SDKs
- *  used an older Xlib.
- */
-#define SDL_VIDEO_DRIVER_X11_XINPUT2 1
-#define SDL_VIDEO_DRIVER_X11_SUPPORTS_GENERIC_EVENTS 1
-#define SDL_VIDEO_DRIVER_X11_CONST_PARAM_XEXTADDDISPLAY 1
-#endif
-
-#ifndef SDL_VIDEO_RENDER_OGL
-#define SDL_VIDEO_RENDER_OGL    1
-#endif
-
-/* Enable OpenGL support */
-#ifndef SDL_VIDEO_OPENGL
-#define SDL_VIDEO_OPENGL    1
-#endif
-#ifndef SDL_VIDEO_OPENGL_CGL
-#define SDL_VIDEO_OPENGL_CGL    1
-#endif
-#ifndef SDL_VIDEO_OPENGL_GLX
-#define SDL_VIDEO_OPENGL_GLX    1
-#endif
-
-/* Enable Vulkan support */
-/* Metal/MoltenVK/Vulkan only supported on 64-bit architectures and 10.11+ */
-#if TARGET_CPU_X86_64
-#define SDL_VIDEO_VULKAN 1
-#else
-#define  SDL_VIDEO_VULKAN 0
-#endif
-
-/* Enable system power support */
-#define SDL_POWER_MACOSX 1
-
-/* enable filesystem support */
-#define SDL_FILESYSTEM_COCOA   1
-
-/* Enable assembly routines */
-#define SDL_ASSEMBLY_ROUTINES   1
-#ifdef __ppc__
-#define SDL_ALTIVEC_BLITTERS    1
-#endif
-
-#endif /* SDL_config_macosx_h_ */
diff -ruN --binary -x '.*' -x patched s25client/external/liblobby/CMakeLists.txt s25client_patched/external/liblobby/CMakeLists.txt
--- s25client/external/liblobby/CMakeLists.txt	2025-06-14 12:47:29.607320443 +0200
+++ s25client_patched/external/liblobby/CMakeLists.txt	2025-06-14 12:55:20.558113304 +0200
@@ -20,7 +20,13 @@
 
 add_library(lobby STATIC EXCLUDE_FROM_ALL ${SOURCES_LOBBY})
 target_include_directories(lobby PUBLIC include)
-target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext)
+
+if(ANDROID)
+    target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext log)
+else()
+    target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext)
+endif()
+
 target_compile_features(lobby PUBLIC cxx_std_17)
 set_target_properties(lobby PROPERTIES CXX_EXTENSIONS OFF)
 
diff -ruN --binary -x '.*' -x patched s25client/external/liblobby/src/LobbyClient.cpp s25client_patched/external/liblobby/src/LobbyClient.cpp
--- s25client/external/liblobby/src/LobbyClient.cpp	2025-06-14 12:47:29.608647574 +0200
+++ s25client_patched/external/liblobby/src/LobbyClient.cpp	2025-06-14 12:55:20.558554331 +0200
@@ -3,6 +3,9 @@
 //
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "liblobby/LobbyClient.h"
 #include "liblobby/LobbyInterface.h"
@@ -26,6 +29,9 @@
 
 LobbyClient::~LobbyClient()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::~LobbyClient() trennen von verbindung zum server"); //ANDROID
+    #endif
     Stop();
 }
 
@@ -45,12 +51,25 @@
  */
 void LobbyClient::Run()
 {
-    if(state == CS_STOPPED)
+    #ifdef ANDROID
+    if(state == CS_STOPPED) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run() lobbyclient state is stopped returning"); //ANDROID
         return;
+    }
+    #else
+    if(state == CS_STOPPED)
+    return;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run()"); //ANDROID
+    #endif
     // nachrichten empfangen
     if(recv_queue.recvAll(socket) < 0)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run()"); //ANDROID
+        #endif
         LOG.write("Receiving Message from server failed\n");
         ServerLost();
         return;
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/cmake/cmake_3.14/FindBoost.cmake s25client_patched/external/libutil/cmake/cmake_3.14/FindBoost.cmake
--- s25client/external/libutil/cmake/cmake_3.14/FindBoost.cmake	2025-06-14 12:47:29.636320412 +0200
+++ s25client_patched/external/libutil/cmake/cmake_3.14/FindBoost.cmake	2025-06-14 12:55:20.559359662 +0200
@@ -283,6 +283,7 @@
 endif()
 
 
+
 #-------------------------------------------------------------------------------
 #  FindBoost functions & macros
 #
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/cmake/FindMiniupnpc.cmake s25client_patched/external/libutil/cmake/FindMiniupnpc.cmake
--- s25client/external/libutil/cmake/FindMiniupnpc.cmake	2025-06-14 12:47:29.635956468 +0200
+++ s25client_patched/external/libutil/cmake/FindMiniupnpc.cmake	2025-06-14 12:55:20.560356138 +0200
@@ -9,6 +9,7 @@
 #  MINIUPNPC_LIBRARY     - Library to link to libminiupnpc.
 #  MINIUPNPC_FOUND       - True if libminiupnpc found.
 
+
 FIND_PATH(MINIUPNPC_INCLUDE_DIR NAMES miniupnpc/miniupnpc.h PATHS
 	${MINIUPNPC_DIR_SEARCH}/miniupnpc/include
 	/usr/include
@@ -21,6 +22,7 @@
 	/usr/local/lib
 )
 
+
 INCLUDE(FindPackageHandleStandardArgs)
 FIND_PACKAGE_HANDLE_STANDARD_ARGS(Miniupnpc DEFAULT_MSG MINIUPNPC_INCLUDE_DIR MINIUPNPC_LIBRARY)
 
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/libs/common/CMakeLists.txt s25client_patched/external/libutil/libs/common/CMakeLists.txt
--- s25client/external/libutil/libs/common/CMakeLists.txt	2025-06-14 12:47:29.637210126 +0200
+++ s25client_patched/external/libutil/libs/common/CMakeLists.txt	2025-06-14 12:55:20.560774465 +0200
@@ -2,6 +2,10 @@
 #
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+if(ANDROID)
+    find_library(SDL2 SDL2) #ANDROID
+endif()
+
 set(_BoostComponents filesystem)
 if(WIN32)
     # Locale only on windows
@@ -19,7 +23,13 @@
 add_library(s25util::common ALIAS s25util_common)
 
 target_include_directories(s25util_common PUBLIC include PRIVATE include/s25util)
-target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem)
+
+if(ANDROID)
+    target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem SDL2)
+else()
+    target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem)
+endif()
+
 target_compile_features(s25util_common PUBLIC cxx_std_17)
 # PIC Required for linking into shared libs
 set_target_properties(s25util_common PROPERTIES CXX_EXTENSIONS OFF POSITION_INDEPENDENT_CODE ON)
diff -ruN --binary -x '.*' -x patched s25client/extras/ai-battle/CMakeLists.txt s25client_patched/extras/ai-battle/CMakeLists.txt
--- s25client/extras/ai-battle/CMakeLists.txt	2025-06-14 12:47:10.975269272 +0200
+++ s25client_patched/extras/ai-battle/CMakeLists.txt	2025-06-14 12:55:20.561127042 +0200
@@ -2,7 +2,12 @@
 #
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+if(ANDROID)
+add_library(ai-battle main.cpp HeadlessGame.cpp)
+else()
 add_executable(ai-battle main.cpp HeadlessGame.cpp)
+endif()
+
 target_link_libraries(ai-battle PRIVATE s25Main Boost::program_options Boost::nowide)
 
 if(WIN32)
diff -ruN --binary -x '.*' -x patched s25client/extras/audioDrivers/SDL/CMakeLists.txt s25client_patched/extras/audioDrivers/SDL/CMakeLists.txt
--- s25client/extras/audioDrivers/SDL/CMakeLists.txt	2025-06-14 12:47:10.975562016 +0200
+++ s25client_patched/extras/audioDrivers/SDL/CMakeLists.txt	2025-06-14 12:55:20.561482879 +0200
@@ -20,9 +20,11 @@
     target_link_libraries(audioSDL PRIVATE audiodrv SDL_mixer::SDL_mixer)
     enable_warnings(audioSDL)
 
-    install(TARGETS audioSDL
-      RUNTIME DESTINATION ${RTTR_DRIVERDIR}/audio
-      LIBRARY DESTINATION ${RTTR_DRIVERDIR}/audio
-    )
+    if(!ANDROID)
+        install(TARGETS audioSDL
+          RUNTIME DESTINATION ${RTTR_DRIVERDIR}/audio
+          LIBRARY DESTINATION ${RTTR_DRIVERDIR}/audio
+        )
+    endif()
     add_dependencies(drivers audioSDL)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/CMakeLists.txt s25client_patched/extras/videoDrivers/SDL2/CMakeLists.txt
--- s25client/extras/videoDrivers/SDL2/CMakeLists.txt	2025-06-14 12:47:10.976262319 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/CMakeLists.txt	2025-06-14 12:55:20.561872189 +0200
@@ -7,7 +7,13 @@
 
 if(SDL2_FOUND)
     add_library(videoSDL2 SHARED ${RTTR_DRIVER_INTERFACE} VideoSDL2.cpp VideoSDL2.h icon.h icon.cpp)
-    target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2)
+    
+    if(ANDROID)
+        target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2 log GL)
+    else()
+        target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2)
+    endif()
+    
     enable_warnings(videoSDL2)
 
     if(WIN32)
@@ -15,9 +21,11 @@
         gather_dll_by_name(SDL2 SDL2.dll)
     endif()
 
-    install(TARGETS videoSDL2
-      RUNTIME DESTINATION ${RTTR_DRIVERDIR}/video
-      LIBRARY DESTINATION ${RTTR_DRIVERDIR}/video
-    )
+    if (!ANDROID)
+        install(TARGETS videoSDL2
+          RUNTIME DESTINATION ${RTTR_DRIVERDIR}/video
+          LIBRARY DESTINATION ${RTTR_DRIVERDIR}/video
+        )
+    endif()
     add_dependencies(drivers videoSDL2)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/VideoSDL2.cpp s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.cpp
--- s25client/extras/videoDrivers/SDL2/VideoSDL2.cpp	2025-06-14 12:47:10.976302842 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.cpp	2025-06-14 12:55:20.562319277 +0200
@@ -2,6 +2,11 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#include <gl4esinit.h>
+#endif
+
 #include "VideoSDL2.h"
 #include "driver/Interface.h"
 #include "driver/VideoDriverLoaderInterface.h"
@@ -109,6 +114,9 @@
 
 bool VideoSDL2::CreateScreen(const std::string& title, const VideoMode& size, bool fullscreen)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoSDL2::CreateScreen initialized? %d", initialized); //ANDROID
+    #endif
     if(!initialized)
         return false;
 
@@ -117,11 +125,16 @@
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RTTR_OGL_MINOR));
     SDL_GLprofile profile;
     if((RTTR_OGL_ES))
-        profile = SDL_GL_CONTEXT_PROFILE_ES;
+	profile = SDL_GL_CONTEXT_PROFILE_ES;
     else if((RTTR_OGL_COMPAT))
         profile = SDL_GL_CONTEXT_PROFILE_COMPATIBILITY;
     else
         profile = SDL_GL_CONTEXT_PROFILE_CORE;
+
+    #ifdef ANDROID
+    profile = SDL_GL_CONTEXT_PROFILE_ES;
+    #endif
+    
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile));
 
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8));
@@ -129,7 +142,11 @@
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8));
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1));
 
+    #ifdef ANDROID
+    int wndPos = SDL_WINDOWPOS_UNDEFINED;
+    #else
     int wndPos = SDL_WINDOWPOS_CENTERED;
+    #endif
 
     const auto requestedSize = fullscreen ? FindClosestVideoMode(size) : size;
     unsigned commonFlags = SDL_WINDOW_OPENGL;
@@ -165,7 +182,7 @@
     {
         SDL_SetWindowIcon(window, iconSurf);
         SDL_FreeSurface(iconSurf);
-    } else
+    } else 
         PrintError(SDL_GetError());
 
     context = SDL_GL_CreateContext(window);
@@ -265,6 +282,17 @@
 
 bool VideoSDL2::MessageLoop()
 {
+    int windowW, windowH;
+    SDL_GetWindowSize(window, &windowW, &windowH);
+    
+    #ifdef ANDROID
+    /*float finger1x = 0;
+    float finger1y = 0;
+    float finger2x = 0;
+    float finger2y = 0;*/
+    SDL_TouchID touchDevice = SDL_GetTouchDevice(1);
+    #endif
+    
     SDL_Event ev;
     while(SDL_PollEvent(&ev))
     {
@@ -400,6 +428,61 @@
                 mouse_xy.pos = getGuiScale().screenToView(Position(ev.motion.x, ev.motion.y));
                 CallBack->Msg_MouseMove(mouse_xy);
                 break;
+            #ifdef ANDROID
+            case SDL_FINGERDOWN:
+                ev.tfinger.x = ev.tfinger.x * windowW;
+                ev.tfinger.y = ev.tfinger.y * windowH;
+                
+                mouse_xy.pos = getGuiScale().screenToView(Position((int)ev.tfinger.x, (int)ev.tfinger.y));
+                mouse_xy.ldown = true;
+                CallBack->Msg_LeftDown(mouse_xy);
+                break;
+            case SDL_FINGERUP:
+                if(!SDL_GetNumTouchFingers(touchDevice))
+                    isMultigesture = false;
+                
+                ev.tfinger.x = ev.tfinger.x * windowW;
+                ev.tfinger.y = ev.tfinger.y * windowH;
+                
+                mouse_xy.pos = getGuiScale().screenToView(Position((int)ev.tfinger.x, (int)ev.tfinger.y));
+                mouse_xy.ldown = false;
+                CallBack->Msg_LeftUp(mouse_xy);
+                break;
+            case SDL_MULTIGESTURE:
+            {
+                isMultigesture = true;
+                if( fabs( ev.mgesture.dDist ) > 0.001 ) {
+                    if( ev.mgesture.dDist > 0 ) {
+                        CallBack->Msg_WheelUp(mouse_xy);
+                    } else {
+                        CallBack->Msg_WheelDown(mouse_xy);
+                    }
+                }
+            }
+                break;
+            case SDL_FINGERMOTION:
+                if (isMultigesture || SDL_GetNumTouchFingers(touchDevice) > 1) {
+                    break;
+                    
+                    /*SDL_Finger* finger1 = SDL_GetTouchFinger(touchDevice, 0);
+                    finger1x = finger1->x;
+                    finger1y = finger1->y;
+                    
+                    SDL_Finger* finger2 = SDL_GetTouchFinger(touchDevice, 1);
+                    finger2x = finger2->x;
+                    finger2y = finger2->y;
+                    
+                    ev.tfinger.x = (finger1x + finger2x) / 2.0f * windowW;
+                    ev.tfinger.y = (finger1y + finger2y) / 2.0f * windowH;*/
+                } else {
+                    ev.tfinger.x = ev.tfinger.x * windowW;
+                    ev.tfinger.y = ev.tfinger.y * windowH;
+                }
+                
+                mouse_xy.pos = getGuiScale().screenToView(Position((int)ev.tfinger.x, (int)ev.tfinger.y));
+                CallBack->Msg_MouseMove(mouse_xy);
+                break;
+            #endif
         }
     }
 
@@ -432,7 +515,11 @@
 
 OpenGL_Loader_Proc VideoSDL2::GetLoaderFunction() const
 {
+    #ifdef ANDROID
+    return gl4es_GetProcAddress;
+    #else
     return SDL_GL_GetProcAddress;
+    #endif
 }
 
 void VideoSDL2::SetMousePos(Position pos)
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/VideoSDL2.h s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.h
--- s25client/extras/videoDrivers/SDL2/VideoSDL2.h	2025-06-14 12:47:10.976302842 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.h	2025-06-14 12:55:20.562857582 +0200
@@ -58,6 +58,9 @@
     void HandlePaste();
     void UpdateCurrentSizes();
     void MoveWindowToCenter();
+    #ifdef ANDROID
+    bool isMultigesture;
+    #endif
 
     SDL_Window* window;
     SDL_GLContext context;
diff -ruN --binary -x '.*' -x patched s25client/libs/driver/include/driver/MouseCoords.h s25client_patched/libs/driver/include/driver/MouseCoords.h
--- s25client/libs/driver/include/driver/MouseCoords.h	2025-06-14 12:47:10.978664188 +0200
+++ s25client_patched/libs/driver/include/driver/MouseCoords.h	2025-06-14 12:55:20.563236957 +0200
@@ -32,4 +32,8 @@
 };
 
 /// Maximale Zeitdifferenz in ms für einen Doppeklick
+#ifdef ANDROID
+const unsigned DOUBLE_CLICK_INTERVAL = 150;
+#else
 const unsigned DOUBLE_CLICK_INTERVAL = 500;
+#endif
diff -ruN --binary -x '.*' -x patched s25client/libs/rttrConfig/CMakeLists.txt s25client_patched/libs/rttrConfig/CMakeLists.txt
--- s25client/libs/rttrConfig/CMakeLists.txt	2025-06-14 12:47:10.980327742 +0200
+++ s25client_patched/libs/rttrConfig/CMakeLists.txt	2025-06-14 12:55:20.563614879 +0200
@@ -10,10 +10,19 @@
   src/RttrConfig.h
 )
 target_include_directories(rttrConfig INTERFACE src)
-target_link_libraries(rttrConfig
-    PUBLIC s25util::common Boost::filesystem
-    PRIVATE s25Common
-)
+
+if(ANDROID)
+    target_link_libraries(rttrConfig
+        PUBLIC s25util::common Boost::filesystem log
+        PRIVATE s25Common
+    )
+else()
+    target_link_libraries(rttrConfig
+        PUBLIC s25util::common Boost::filesystem
+        PRIVATE s25Common
+    )
+endif()
+
 set_property(TARGET rttrConfig PROPERTY POSITION_INDEPENDENT_CODE ON)
 
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/build_paths.h.cmake build_paths.h @ONLY)
diff -ruN --binary -x '.*' -x patched s25client/libs/rttrConfig/src/RttrConfig.cpp s25client_patched/libs/rttrConfig/src/RttrConfig.cpp
--- s25client/libs/rttrConfig/src/RttrConfig.cpp	2025-06-14 12:47:10.980541933 +0200
+++ s25client_patched/libs/rttrConfig/src/RttrConfig.cpp	2025-06-14 12:55:20.564070814 +0200
@@ -2,6 +2,10 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
 #include "RttrConfig.h"
 #include "RTTR_Assert.h"
 #include "s25util/Log.h"
@@ -33,9 +37,15 @@
 
 bfs::path RttrConfig::GetPrefixPath()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::getPrefixPath() need to get prefix path"); //ANDROID
+    #endif
     // Determine install prefix
     // Get path to current executable (at least for checks)
     bfs::path fullExeFilepath = System::getExecutablePath();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::getPrefixPath() executablePath %s", fullExeFilepath.c_str()); //ANDROID
+    #endif
     // This should always work unless we have some missing implementation or a bad error
     if(fullExeFilepath.empty())
     {
@@ -89,22 +99,59 @@
 
 boost::filesystem::path RttrConfig::ExpandPath(const std::string& path) const
 {
-    if(path.empty())
+    #ifdef ANDROID
+    if(path.empty()) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  path is empty using prefixPath"); //ANDROID
+        return prefixPath_;
+    }
+    #else
+        if(path.empty())
         return prefixPath_;
+    #endif
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  expanding path: %s", path.c_str()); //ANDROID
+    #endif
+    
     bfs::path outPath;
     if(path[0] == '<')
     {
         static const char rttrPathId[] = "<RTTR_";
         size_t startPos = path.find(rttrPathId);
+
+        #ifdef ANDROID
+        if(startPos > 0u) {
+            throw std::runtime_error("<RTTR_X> placeholders only allowed at start of path");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  <RTTR_X> placeholders only allowed at start of path"); //ANDROID
+        }
+        #else
         if(startPos > 0u)
             throw std::runtime_error("<RTTR_X> placeholders only allowed at start of path");
+        #endif
+
         size_t endPos = path.find('>');
-        if(endPos == std::string::npos)
+        #ifdef ANDROID
+        if(endPos == std::string::npos) {
             throw std::runtime_error("Incomplete <RTTR_X> placeholder found!");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  Incomplete <RTTR_X> placeholder found!"); //ANDROID
+        }
+        #else
+        if(endPos == std::string::npos)
+        throw std::runtime_error("Incomplete <RTTR_X> placeholder found!");
+        #endif
+
         std::string entry = path.substr(sizeof(rttrPathId) - 1, endPos - startPos - sizeof(rttrPathId) + 1);
         auto it = pathMappings.find(entry);
-        if(it == pathMappings.end())
+        #ifdef ANDROID
+        if(it == pathMappings.end()) {
             throw std::runtime_error("Invalid <RTTR_X> placeholder found!");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  Invalid <RTTR_X> placeholder found!"); //ANDROID
+        }
+        #else
+        if(it == pathMappings.end())
+        throw std::runtime_error("Invalid <RTTR_X> placeholder found!");
+        #endif
+
         outPath = bfs::path(it->second) / path.substr(endPos + 1);
     } else
         outPath = path;
@@ -112,6 +159,9 @@
         outPath = homePath / outPath.string().substr(2);
 
     outPath = bfs::absolute(outPath, prefixPath_).lexically_normal();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath returning path: %s", outPath.c_str()); //ANDROID
+    #endif
     return outPath.make_preferred();
 }
 
@@ -123,7 +173,11 @@
 
 bool RttrConfig::Init()
 {
+    #ifdef ANDROID
+    prefixPath_ = System::getHomePath();
+    #else
     prefixPath_ = GetPrefixPath();
+    #endif
     if(prefixPath_.empty())
         return false;
     // Make the prefix path our working directory as all other paths are relative to that
diff -ruN --binary -x '.*' -x patched s25client/libs/s25client/CMakeLists.txt s25client_patched/libs/s25client/CMakeLists.txt
--- s25client/libs/s25client/CMakeLists.txt	2025-06-14 12:47:10.980541933 +0200
+++ s25client_patched/libs/s25client/CMakeLists.txt	2025-06-14 12:55:20.564503305 +0200
@@ -18,9 +18,16 @@
     set(s25client_RC )
 endif()
 
-add_executable(s25client s25client.cpp commands.cpp ${s25client_RC})
-target_link_libraries(s25client PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld)
-add_dependencies(s25client drivers)
+if(ANDROID)
+    add_library(main SHARED s25client.cpp commands.cpp ${s25client_RC})
+    target_link_libraries(main PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld log)
+    add_dependencies(main drivers)
+else()
+    add_executable(s25client s25client.cpp commands.cpp ${s25client_RC})
+    target_link_libraries(s25client PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld)
+    add_dependencies(s25client drivers)
+endif()
+
 
 if(WIN32)
     target_include_directories(s25client PRIVATE ${rcDir})
@@ -46,4 +53,6 @@
     gather_dll_copy(s25client)
 endif()
 
-INSTALL(TARGETS s25client RUNTIME DESTINATION ${RTTR_BINDIR})
+if(NOT ANDROID)
+    INSTALL(TARGETS s25client RUNTIME DESTINATION ${RTTR_BINDIR})
+endif()
diff -ruN --binary -x '.*' -x patched s25client/libs/s25client/s25client.cpp s25client_patched/libs/s25client/s25client.cpp
--- s25client/libs/s25client/s25client.cpp	2025-06-14 12:48:51.375234507 +0200
+++ s25client_patched/libs/s25client/s25client.cpp	2025-06-14 12:55:20.565190944 +0200
@@ -1,6 +1,10 @@
 // Copyright (C) 2005 - 2025 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <SDL.h>
+#include <android/log.h>
+#endif
 
 #include "Debug.h"
 #include "GameManager.h"
@@ -85,6 +89,9 @@
     if(waited)
         return;
     waited = true;
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Press ENTER to close this window . . ."); //ANDROID
+    #endif
     bnw::cout << "\n\nPress ENTER to close this window . . ." << std::endl;
     bnw::cin.clear();
     bnw::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
@@ -142,6 +149,9 @@
 
 void showCrashMessage()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttR crashed. Please restart the application!"); //ANDROID
+    #endif
     std::string text = gettext_noop("RttR crashed. Please restart the application!");
     std::string errorTxt = gettext_noop("Error");
     try
@@ -363,6 +373,9 @@
 
 bool InitDirectories()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() funktion"); //ANDROID
+    #endif
     // Note: Do not use logger yet. Filepath may not exist
     const auto curPath = bfs::current_path();
     LOG.write("Starting in %1%\n", LogTarget::Stdout) % curPath;
@@ -370,14 +383,30 @@
     if(!MigrateFilesAndDirectories())
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Creating all folders"); //ANDROID
+    #endif
     // Create all required/useful folders
     const std::array<std::string, 10> dirs = {
       {s25::folders::config, s25::folders::logs, s25::folders::mapsOwn, s25::folders::mapsPlayed, s25::folders::replays,
        s25::folders::save, s25::folders::assetsUserOverrides, s25::folders::screenshots, s25::folders::playlists}};
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() done creating folders"); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() s25::folders::config %s", s25::folders::config  ); //ANDROID
+    #endif
 
     for(const std::string& rawDir : dirs)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() %s", rawDir.c_str()); //ANDROID
+        #endif
         const bfs::path dir = RTTRCONFIG.ExpandPath(rawDir);
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() %s", dir.c_str()); //ANDROID
+        #endif
         boost::system::error_code ec;
         bfs::create_directories(dir, ec);
         if(ec != boost::system::errc::success)
@@ -386,6 +415,9 @@
             // Make sure we catch that
             try
             {
+                #ifdef ANDROID
+                __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() folders could not be created"); //ANDROID
+                #endif
                 s25util::error(std::string("Directory ") + dir.string() + " could not be created.");
                 s25util::error("Failed to start the game");
             } catch(const std::runtime_error& error)
@@ -395,10 +427,16 @@
             return false;
         }
     }
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Writing log: Directory for user data (config etc.):"); //ANDROID
+    #endif
     LOG.write("Directory for user data (config etc.): %1%\n", LogTarget::Stdout)
       % RTTRCONFIG.ExpandPath(s25::folders::config);
 
     // Write this to file too, after folders are created
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() set log filepath"); //ANDROID
+    #endif
     LOG.setLogFilepath(RTTRCONFIG.ExpandPath(s25::folders::logs));
     try
     {
@@ -407,15 +445,24 @@
         LOG.write("Starting in %1%\n", LogTarget::File) % curPath;
     } catch(const std::exception& e)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Error initializing log: \n" ); //ANDROID
+        #endif
         LOG.write("Error initializing log: %1%\nSystem reports: %2%\n", LogTarget::Stderr) % e.what()
           % LOG.getLastError();
         return false;
     }
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Returning TRUE"); //ANDROID
+    #endif
     return true;
 }
 
 bool InitGame(GameManager& gameManager)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitGame Funktion"); //ANDROID
+    #endif
     libsiedler2::setAllocator(new GlAllocator());
 
     // Socketzeug initialisieren
@@ -425,10 +472,16 @@
         s25util::error("Failed to start the game");
         return false;
     }
-
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "SPIEL STARTEN!!"); //ANDROID
+    #endif
     // Spiel starten
     if(!gameManager.Start())
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Failed to start the game"); //ANDROID
+        #endif
         s25util::error("Failed to start the game");
         return false;
     }
@@ -450,6 +503,9 @@
         return 1;
 
     // Zufallsgenerator initialisieren (Achtung: nur für Animations-Offsets interessant, für alles andere
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Directories created successfully!"); //ANDROID
+    #endif
     // (spielentscheidende) wird unser Generator verwendet)
     srand(static_cast<unsigned>(std::time(nullptr)));
 
@@ -457,10 +513,16 @@
     {
         try
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Convert sounds"); //ANDROID
+            #endif
             convertAndSaveSounds(RTTRCONFIG, RTTRCONFIG.ExpandPath("<RTTR_USERDATA>/convertedSoundeffects"));
             return 0;
         } catch(const std::runtime_error& e)
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Error: %s", e.what()); //ANDROID
+            #endif
             bnw::cerr << "Error: " << e.what() << "\n";
             return 1;
         }
@@ -470,6 +532,9 @@
                                                       WINDOWMANAGER);
     try
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() running initgame(gamemanager)"); //ANDROID
+        #endif
         if(!InitGame(gameManager))
             return 2;
 
@@ -484,6 +549,10 @@
         }
 
         // Hauptschleife
+        
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Hauptschleife..."); //ANDROID
+        #endif
 
         while(gameManager.Run())
         {
@@ -492,6 +561,10 @@
 #endif // !_WIN32
         }
 
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Killing game"); //ANDROID
+        #endif
+
         // Spiel beenden
         gameManager.Stop();
         libsiedler2::setAllocator(nullptr);
@@ -522,6 +595,15 @@
 // NOLINTNEXTLINE(bugprone-exception-escape)
 int main(int argc, char** argv)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Starting Main function, %s", SDL_AndroidGetInternalStoragePath()); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
+    SDL_SetHint(SDL_HINT_TOUCH_MOUSE_EVENTS, "0");  // Converts touch events to mouse events
+    SDL_SetHint(SDL_HINT_MOUSE_TOUCH_EVENTS, "0");  // Converts mouse events to touch events
+    #endif
+
     bnw::args _(argc, argv);
 
     po::options_description desc("Allowed options");
@@ -570,11 +652,17 @@
         result = e.code;
     } catch(const std::exception& e)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "An exception occurred: %s", e.what()); //ANDROID
+        #endif
         bnw::cerr << "An exception occurred: " << e.what() << std::endl;
         handleException(nullptr);
         result = 1;
     } catch(...)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "An unknown exception occurred!"); //ANDROID
+        #endif
         bnw::cerr << "An unknown exception occurred" << std::endl;
         handleException(nullptr);
         result = 1;
@@ -582,5 +670,8 @@
     if(result)
         WaitForEnter();
 
+    #ifdef ANDROID
+    exit(result); //to full close android app
+    #endif
     return result;
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/CMakeLists.txt s25client_patched/libs/s25main/CMakeLists.txt
--- s25client/libs/s25main/CMakeLists.txt	2025-06-14 12:48:51.375234507 +0200
+++ s25client_patched/libs/s25main/CMakeLists.txt	2025-06-14 12:55:20.566149823 +0200
@@ -50,20 +50,37 @@
 set_target_properties(s25Main PROPERTIES CXX_EXTENSIONS OFF)
 target_compile_features(s25Main PUBLIC cxx_std_17)
 
-target_link_libraries(s25Main PUBLIC
-    siedler2
-    lobby_c
-    s25util::common
-    s25util::network
-    mygettext
-    s25Common
-    rttrConfig
-    gamedata
-    glad
-    driver
-    Boost::filesystem Boost::disable_autolinking
-    PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::nowide samplerate_cpp
+if(ANDROID)
+    target_link_libraries(s25Main PUBLIC
+        siedler2
+        lobby_c
+        s25util::common
+        s25util::network
+        mygettext
+        s25Common
+        rttrConfig
+        gamedata
+        glad
+        driver
+        Boost::filesystem Boost::disable_autolinking
+        PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::system Boost::thread Boost::nowide samplerate_cpp log iconv
 )
+else()
+    target_link_libraries(s25Main PUBLIC
+        siedler2
+        lobby_c
+        s25util::common
+        s25util::network
+        mygettext
+        s25Common
+        rttrConfig
+        gamedata
+        glad
+        driver
+        Boost::filesystem Boost::disable_autolinking
+        PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::system Boost::thread Boost::nowide samplerate_cpp
+)
+endif()
 
 if(WIN32 OR CYGWIN)
     include(CheckIncludeFiles)
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/desktops/dskGameInterface.cpp s25client_patched/libs/s25main/desktops/dskGameInterface.cpp
--- s25client/libs/s25main/desktops/dskGameInterface.cpp	2025-06-14 12:47:10.997340344 +0200
+++ s25client_patched/libs/s25main/desktops/dskGameInterface.cpp	2025-06-14 12:55:20.567078247 +0200
@@ -88,6 +88,8 @@
 #include <cstdio>
 #include <utility>
 
+#include <android/log.h>
+
 namespace {
 enum
 {
@@ -98,7 +100,6 @@
     ID_txtNumMsg
 };
 }
-
 dskGameInterface::dskGameInterface(std::shared_ptr<Game> game, std::shared_ptr<const NWFInfo> nwfInfo,
                                    unsigned playerIdx, bool initOGL)
     : Desktop(nullptr), game_(std::move(game)), nwfInfo_(std::move(nwfInfo)),
@@ -215,7 +216,13 @@
 
 void dskGameInterface::StartScrolling(const Position& mousePos)
 {
+    #ifdef ANDROID
+    (void)mousePos; //just to avoid compiler error... I'm sorry guys :D
+    
+    startScrollPt = gwv.getWorldMousePos();
+    #else
     startScrollPt = mousePos;
+    #endif
     isScrolling = true;
     WINDOWMANAGER.SetCursor(Cursor::Scroll);
 }
@@ -463,6 +470,267 @@
         iconPos -= DrawPoint(magnifierImg->getWidth() + 4, 0);
     }
 }
+#ifdef ANDROID
+bool dskGameInterface::simpleLeftClick(const MouseCoords& mc)
+{
+    DrawPoint btOrig(VIDEODRIVER.GetRenderSize().x / 2 - LOADER.GetImageN("resource", 29)->getWidth() / 2 + 44,
+                     VIDEODRIVER.GetRenderSize().y - LOADER.GetImageN("resource", 29)->getHeight() + 4);
+    Extent btSize = Extent(37, 32) * 4u;
+    if(IsPointInRect(mc.GetPos(), Rect(btOrig, btSize)))
+        return false;
+
+    // Start scrolling also on Ctrl + left click
+    if(VIDEODRIVER.GetModKeyState().ctrl)
+    {
+        Msg_RightDown(mc);
+        return true;
+    } else if(isScrolling)
+        StopScrolling();
+
+    // Unterscheiden je nachdem Straäcnbaumodus an oder aus ist
+    if(road.mode != RoadBuildMode::Disabled)
+    {
+        // in "richtige" Map-Koordinaten Konvertieren, den aktuellen selektierten Punkt
+        const MapPoint selPt = gwv.GetSelectedPt();
+
+        if(selPt == road.point)
+        {
+            // Selektierter Punkt ist der gleiche wie der Straßenpunkt --> Fenster mit Wegbau abbrechen
+            ShowRoadWindow(mc.GetPos());
+        } else
+        {
+            // altes Roadwindow schließen
+            WINDOWMANAGER.Close((unsigned)CGI_ROADWINDOW);
+
+            // Ist das ein gültiger neuer Wegpunkt?
+            if(worldViewer.IsRoadAvailable(road.mode == RoadBuildMode::Boat, selPt)
+               && worldViewer.IsPlayerTerritory(selPt))
+            {
+                MapPoint targetPt = selPt;
+                if(!BuildRoadPart(targetPt))
+                    ShowRoadWindow(mc.GetPos());
+            } else if(worldViewer.GetBQ(selPt) != BuildingQuality::Nothing)
+            {
+                // Wurde bereits auf das gebaute Stück geklickt?
+                unsigned idOnRoad = GetIdInCurBuildRoad(selPt);
+                if(idOnRoad)
+                    DemolishRoad(idOnRoad);
+                else
+                {
+                    MapPoint targetPt = selPt;
+                    if(BuildRoadPart(targetPt))
+                    {
+                        // Ist der Zielpunkt der gleiche geblieben?
+                        if(selPt == targetPt)
+                            GI_BuildRoad();
+                    } else if(selPt == targetPt)
+                        ShowRoadWindow(mc.GetPos());
+                }
+            }
+            // Wurde auf eine Flagge geklickt und ist diese Flagge nicht der Weganfangspunkt?
+            else if(worldViewer.GetWorld().GetNO(selPt)->GetType() == NodalObjectType::Flag && selPt != road.start)
+            {
+                MapPoint targetPt = selPt;
+                if(BuildRoadPart(targetPt))
+                {
+                    if(selPt == targetPt)
+                        GI_BuildRoad();
+                } else if(selPt == targetPt)
+                    ShowRoadWindow(mc.GetPos());
+            } else
+            {
+                unsigned tbr = GetIdInCurBuildRoad(selPt);
+                // Wurde bereits auf das gebaute Stück geklickt?
+                if(tbr)
+                    DemolishRoad(tbr);
+                else
+                    ShowRoadWindow(mc.GetPos());
+            }
+        }
+    } else
+    {
+        bool enable_military_buildings = false;
+
+        iwAction::Tabs action_tabs;
+
+        const MapPoint cSel = gwv.GetSelectedPt();
+
+        // Vielleicht steht hier auch ein Schiff?
+        if(const noShip* ship = worldViewer.GetShip(cSel))
+        {
+            WINDOWMANAGER.Show(std::make_unique<iwShip>(gwv, GAMECLIENT, ship));
+            return true;
+        }
+
+        // Evtl ists nen Haus? (unser Haus)
+        const noBase& selObj = *worldViewer.GetWorld().GetNO(cSel);
+        if(selObj.GetType() == NodalObjectType::Building && worldViewer.IsOwner(cSel))
+        {
+            if(auto* wnd = WINDOWMANAGER.FindNonModalWindow(CGI_BUILDING + MapBase::CreateGUIID(cSel)))
+            {
+                WINDOWMANAGER.SetActiveWindow(*wnd);
+                return true;
+            }
+            BuildingType bt = static_cast<const noBuilding&>(selObj).GetBuildingType();
+            // HQ
+            if(bt == BuildingType::Headquarters)
+                WINDOWMANAGER.Show(
+                  std::make_unique<iwHQ>(gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobHQ>(cSel)));
+            // Lagerhäuser
+            else if(bt == BuildingType::Storehouse)
+                WINDOWMANAGER.Show(std::make_unique<iwBaseWarehouse>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobStorehouse>(cSel)));
+            // Hafengebäude
+            else if(bt == BuildingType::HarborBuilding)
+                WINDOWMANAGER.Show(std::make_unique<iwHarborBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobHarborBuilding>(cSel)));
+            // Militärgebäude
+            else if(BuildingProperties::IsMilitary(bt))
+                WINDOWMANAGER.Show(std::make_unique<iwMilitaryBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobMilitary>(cSel)));
+            else if(bt == BuildingType::Temple)
+                WINDOWMANAGER.Show(std::make_unique<iwTempleBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobTemple>(cSel)));
+            else
+                WINDOWMANAGER.Show(std::make_unique<iwBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobUsual>(cSel)));
+            return true;
+        }
+        // oder vielleicht eine Baustelle?
+        else if(selObj.GetType() == NodalObjectType::Buildingsite && worldViewer.IsOwner(cSel))
+        {
+            if(!WINDOWMANAGER.FindNonModalWindow(CGI_BUILDING + MapBase::CreateGUIID(cSel)))
+                WINDOWMANAGER.Show(
+                  std::make_unique<iwBuildingSite>(gwv, worldViewer.GetWorld().GetSpecObj<noBuildingSite>(cSel)));
+            return true;
+        }
+
+        action_tabs.watch = true;
+        // Unser Land
+        if(worldViewer.IsOwner(cSel))
+        {
+            const BuildingQuality bq = worldViewer.GetBQ(cSel);
+            // Kann hier was gebaut werden?
+            if(bq >= BuildingQuality::Mine)
+            {
+                action_tabs.build = true;
+
+                // Welches Gebäude kann gebaut werden?
+                switch(bq)
+                {
+                    case BuildingQuality::Mine: action_tabs.build_tabs = iwAction::BuildTab::Mine; break;
+                    case BuildingQuality::Hut: action_tabs.build_tabs = iwAction::BuildTab::Hut; break;
+                    case BuildingQuality::House: action_tabs.build_tabs = iwAction::BuildTab::House; break;
+                    case BuildingQuality::Castle: action_tabs.build_tabs = iwAction::BuildTab::Castle; break;
+                    case BuildingQuality::Harbor: action_tabs.build_tabs = iwAction::BuildTab::Harbor; break;
+                    default: break;
+                }
+
+                if(!worldViewer.GetWorld().IsFlagAround(cSel))
+                    action_tabs.setflag = true;
+
+                // Prüfen, ob sich Militärgebäude in der Nähe befinden, wenn nein, können auch eigene
+                // Militärgebäude gebaut werden
+                enable_military_buildings =
+                  !worldViewer.GetWorld().IsMilitaryBuildingNearNode(cSel, worldViewer.GetPlayerId());
+            } else if(bq == BuildingQuality::Flag)
+                action_tabs.setflag = true;
+            else if(selObj.GetType() == NodalObjectType::Flag)
+                action_tabs.flag = true;
+
+            if(selObj.GetType() != NodalObjectType::Flag && selObj.GetType() != NodalObjectType::Building)
+            {
+                // Check if there are roads
+                for(const Direction dir : helpers::EnumRange<Direction>{})
+                {
+                    const PointRoad curRoad = worldViewer.GetVisiblePointRoad(cSel, dir);
+                    if(curRoad != PointRoad::None)
+                    {
+                        action_tabs.cutroad = true;
+                        action_tabs.upgradeRoad |= (curRoad == PointRoad::Normal);
+                    }
+                }
+            }
+        }
+        // evtl ists ein feindliches Militärgebäude, welches NICHT im Nebel liegt?
+        else if(worldViewer.GetVisibility(cSel) == Visibility::Visible)
+        {
+            if(selObj.GetType() == NodalObjectType::Building)
+            {
+                const auto* building = worldViewer.GetWorld().GetSpecObj<noBuilding>(cSel); //-V807
+                BuildingType bt = building->GetBuildingType();
+
+                // Only if trade is enabled
+                if(worldViewer.GetWorld().GetGGS().isEnabled(AddonId::TRADE))
+                {
+                    // Allied warehouse? -> Show trade window
+                    if(BuildingProperties::IsWareHouse(bt) && worldViewer.GetPlayer().IsAlly(building->GetPlayer()))
+                    {
+                        WINDOWMANAGER.Show(std::make_unique<iwTrade>(*static_cast<const nobBaseWarehouse*>(building),
+                                                                     worldViewer, GAMECLIENT));
+                        return true;
+                    }
+                }
+
+                // Ist es ein gewöhnliches Militärgebäude?
+                if(BuildingProperties::IsMilitary(bt))
+                {
+                    // Dann darf es nicht neu gebaut sein!
+                    if(!static_cast<const nobMilitary*>(building)->IsNewBuilt())
+                        action_tabs.attack = true;
+                }
+                // oder ein HQ oder Hafen?
+                else if(bt == BuildingType::Headquarters || bt == BuildingType::HarborBuilding)
+                    action_tabs.attack = true;
+                action_tabs.sea_attack =
+                  action_tabs.attack && worldViewer.GetWorld().GetGGS().isEnabled(AddonId::SEA_ATTACK);
+            }
+        }
+
+        // Bisheriges Actionfenster schließen, falls es eins gab
+        // aktuelle Mausposition merken, da diese durch das Schließen verändert werden kann
+        if(actionwindow)
+            actionwindow->Close();
+        VIDEODRIVER.SetMousePos(mc.GetPos());
+
+        ShowActionWindow(action_tabs, cSel, mc.GetPos(), enable_military_buildings);
+    }
+
+    return true;
+}
+
+bool dskGameInterface::Msg_LeftDown(const MouseCoords& mc)
+{
+    leftButtonDown = true;
+    leftDownStart = VIDEODRIVER.GetTickCount();
+     
+    if(mouseMove)
+    {
+        Msg_RightDown(mc);
+        return true;
+    } else if(isScrolling)
+        StopScrolling();
+    
+    //return simpleLeftClick(mc);
+    return true;
+}
+
+bool dskGameInterface::Msg_LeftUp(const MouseCoords& mc)
+{
+    leftButtonDown = false;
+    unsigned long leftDownDuration = VIDEODRIVER.GetTickCount() - leftDownStart;
+    
+    if(leftDownDuration < 125)
+	simpleLeftClick(mc);
+    
+    if(isScrolling)
+    {
+        StopScrolling();
+        return true;
+    }
+    return false;
+}
+#else
 
 bool dskGameInterface::Msg_LeftDown(const MouseCoords& mc)
 {
@@ -694,6 +962,7 @@
 
 bool dskGameInterface::Msg_LeftUp(const MouseCoords&)
 {
+    mouseMove = false;
     if(isScrolling)
     {
         StopScrolling();
@@ -701,9 +970,14 @@
     }
     return false;
 }
+#endif
 
-bool dskGameInterface::Msg_MouseMove(const MouseCoords& mc)
+bool dskGameInterface::Msg_MouseMove(const MouseCoords& mc) //gwv.MoveBy android
 {
+    mouseMove = true;
+    
+    mc.GetPos();
+    
     if(!isScrolling)
         return false;
 
@@ -711,12 +985,23 @@
 
     if(SETTINGS.interface.invertMouse)
         acceleration = -acceleration;
-
+    
+    #ifdef ANDROID
+    //int zoomLv = zoomLvl;
+    
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ZOOM LEVEL: %i", static_cast<int>(zoomLvl)); //ANDROID
+    
+    if(SETTINGS.interface.invertMouse) {
+        gwv.MoveBy((gwv.getWorldMousePos() - startScrollPt) * -1); //((6 - static_cast<int>(zoomLvl)) / 2)
+    } else
+        gwv.MoveBy((gwv.getWorldMousePos() - startScrollPt));
+    #else
     gwv.MoveBy((mc.GetPos() - startScrollPt) * acceleration);
     VIDEODRIVER.SetMousePos(startScrollPt);
+    #endif
 
     if(!SETTINGS.global.smartCursor)
-        startScrollPt = mc.GetPos();
+        startScrollPt = gwv.getWorldMousePos();
     return true;
 }
 
@@ -899,7 +1184,7 @@
     return false;
 }
 
-bool dskGameInterface::Msg_WheelUp(const MouseCoords&)
+bool dskGameInterface::Msg_WheelUp(const MouseCoords&) //ANDROID ZOOM TESTING 
 {
     WheelZoom(ZOOM_WHEEL_INCREMENT);
     return true;
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/desktops/dskGameInterface.h s25client_patched/libs/s25main/desktops/dskGameInterface.h
--- s25client/libs/s25main/desktops/dskGameInterface.h	2025-06-14 12:47:10.997340344 +0200
+++ s25client_patched/libs/s25main/desktops/dskGameInterface.h	2025-06-14 12:55:20.568096114 +0200
@@ -121,6 +121,9 @@
     void Msg_PaintBefore() override;
     void Msg_PaintAfter() override;
     bool Msg_LeftDown(const MouseCoords& mc) override;
+    #ifdef ANDROID
+    bool simpleLeftClick(const MouseCoords& mc);
+    #endif
     bool Msg_LeftUp(const MouseCoords& mc) override;
     bool Msg_MouseMove(const MouseCoords& mc) override;
     bool Msg_RightDown(const MouseCoords& mc) override;
@@ -167,6 +170,12 @@
     Position startScrollPt;
     size_t zoomLvl;
     Subscription evBld;
+    
+    #ifdef ANDROID
+    bool mouseMove;
+    bool leftButtonDown;
+    unsigned long leftDownStart;
+    #endif
 
     Cheats cheats_;
     CheatCommandTracker cheatCommandTracker_;
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/drivers/DriverWrapper.cpp s25client_patched/libs/s25main/drivers/DriverWrapper.cpp
--- s25client/libs/s25main/drivers/DriverWrapper.cpp	2025-06-14 12:47:10.999373126 +0200
+++ s25client_patched/libs/s25main/drivers/DriverWrapper.cpp	2025-06-14 12:55:20.568594109 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "DriverWrapper.h"
 #include "ListDir.h"
@@ -44,17 +47,37 @@
 bool DriverWrapper::Load(const DriverType dt, std::string& preference)
 {
     // ggf. aufräumen vorher
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() unloading driver(if needed) "); //ANDROID
+    #endif
     Unload();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() driver unloaded "); //ANDROID
+    #endif
+
     /// Verfügbare Treiber auflisten
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() list drivers "); //ANDROID
+    #endif
     std::vector<DriverItem> drivers = LoadDriverList(dt);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() writing to log what drivers are found "); //ANDROID
+    #endif
     LOG.write("%u %s drivers found!\n") % drivers.size() % getName(dt);
 
     // Welche gefunden?
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() treiber gefunden? "); //ANDROID
+    #endif
     if(drivers.empty())
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() Ja treiber gefunden "); //ANDROID
+    #endif
+
     /// Suche, ob der Treiber dabei ist, den wir wünschen
     const auto it = helpers::find_if(drivers, [preference](const auto& it) { return it.GetName() == preference; });
     if(it != drivers.end())
@@ -129,11 +152,22 @@
     return true;
 }
 
+
 std::vector<DriverWrapper::DriverItem> DriverWrapper::LoadDriverList(const DriverType dt)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers"); //ANDROID
+    #endif
     std::vector<DriverItem> driver_list;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers"); //ANDROID
+    #endif
+    #ifdef ANDROID
+    const bfs::path& driverDir = getenv("libDir") + getName(dt);
+    #else
     const auto driverDir = RTTRCONFIG.ExpandPath(s25::folders::driver) / getName(dt);
+    #endif
     std::string extension =
 #ifdef _WIN32
       "dll";
@@ -145,6 +179,9 @@
 #    endif // !__APPLE__
 #endif     // !_WIN32
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers in %s", driverDir.c_str()); //ANDROID
+    #endif
     LOG.write(_("Searching for drivers in %s\n")) % driverDir;
     const std::vector<boost::filesystem::path> driver_files = ListDir(driverDir, extension, false);
 
@@ -166,10 +203,21 @@
             continue;
 #endif
         std::string nameOrError;
+        #ifdef ANDROID
+        if(!CheckLibrary(path, dt, nameOrError)) {
+            LOG.write(_("Skipping %s: %s\n")) % path % nameOrError;
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() Skipping %s: %s",path.c_str(), nameOrError.c_str()); //ANDROID
+        }
+        else {
+            driver_list.push_back(DriverItem(path, nameOrError));
+             __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() error else %s", nameOrError.c_str()); //ANDROID
+        }
+        #else
         if(!CheckLibrary(path, dt, nameOrError))
             LOG.write(_("Skipping %s: %s\n")) % path % nameOrError;
         else
             driver_list.push_back(DriverItem(path, nameOrError));
+        #endif
     }
     return driver_list;
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/drivers/VideoDriverWrapper.cpp s25client_patched/libs/s25main/drivers/VideoDriverWrapper.cpp
--- s25client/libs/s25main/drivers/VideoDriverWrapper.cpp	2025-06-14 12:47:10.999373126 +0200
+++ s25client_patched/libs/s25main/drivers/VideoDriverWrapper.cpp	2025-06-14 12:55:20.569209063 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "VideoDriverWrapper.h"
 #include "FrameCounter.h"
@@ -35,10 +38,18 @@
 
 VideoDriverWrapper::~VideoDriverWrapper()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::~VideoDriverWrapper()  cleanup"); //ANDROID
+    #endif
     CleanUp();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::~VideoDriverWrapper()  unload driver"); //ANDROID
+    #endif
     UnloadDriver();
 }
 
+void initialize_gl4es();
+
 bool VideoDriverWrapper::Initialize()
 {
     if(!videodriver || !videodriver->Initialize())
@@ -57,18 +68,36 @@
 
 bool VideoDriverWrapper::LoadDriver(IVideoDriver* existingDriver)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver() unloading driver"); //ANDROID
+    #endif
     UnloadDriver();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver() initialize ivideodriver"); //ANDROID
+    #endif
     videodriver = Handle(existingDriver, [](IVideoDriver* p) { delete p; });
     return Initialize();
 }
 
 bool VideoDriverWrapper::LoadDriver(std::string& preference)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() unload driver "); //ANDROID
+    #endif
     UnloadDriver();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() driver unloaded "); //ANDROID
+    #endif
     // DLL laden
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() load driver video "); //ANDROID
+    #endif
     if(!driver_wrapper.Load(drivers::DriverType::Video, preference))
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() driver loaded "); //ANDROID
+    #endif
     auto createVideoInstance = driver_wrapper.GetFunction<CreateVideoInstance_t>("CreateVideoInstance");
     auto freeVideoInstance = driver_wrapper.GetFunction<FreeVideoInstance_t>("FreeVideoInstance");
     RTTR_Assert(createVideoInstance && freeVideoInstance);
@@ -96,32 +125,60 @@
 {
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
 
     if(!videodriver->CreateScreen(rttr::version::GetTitle(), size, fullscreen))
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Could not create window!"); //ANDROID
+        #endif
         s25util::fatal_error("Could not create window!");
         return false;
     }
-
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Window created"); //ANDROID
+    #endif
+
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen loading extensions"); //ANDROID
+    #endif
     // DriverWrapper Initialisieren
     // Extensions laden
     if(!LoadAllExtensions())
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen ERROR! failed to initialize the opengl context!"); //ANDROID
+        #endif
         s25util::fatal_error("Failed to initialize the OpenGL context!");
         return false;
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Renew Viewport..."); //ANDROID
+    #endif
     RenewViewport();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Swapping buffers"); //ANDROID
+    #endif
     // Buffer swappen um den leeren Buffer darzustellen
     SwapBuffers();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen windowmanager msg screenresize(getrendersize())"); //ANDROID
+    #endif
     // WindowManager informieren
     WINDOWMANAGER.Msg_ScreenResize(GetRenderSize());
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen returning true"); //ANDROID
+    #endif
+
     return true;
 }
 
@@ -136,8 +193,15 @@
  */
 bool VideoDriverWrapper::ResizeScreen(const VideoMode size, const bool fullscreen)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ResizeScreen"); //ANDROID
+    #endif
+    
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ResizeScreen No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
@@ -302,9 +366,15 @@
  */
 void VideoDriverWrapper::RenewViewport()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport"); //ANDROID
+    #endif
     if(!videodriver->IsOpenGL() || !renderer_)
         return;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport is video driver not opengl"); //ANDROID
+    #endif
     const Extent renderSize = videodriver->GetRenderSize();
     const VideoMode windowSize = videodriver->GetWindowSize();
 
@@ -312,9 +382,18 @@
     glViewport(0, 0, windowSize.width, windowSize.height);
     glScissor(0, 0, windowSize.width, windowSize.height);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Orthogonale Matrix erstellen"); //ANDROID
+    #endif
     // Orthogonale Matrix erstellen
     glMatrixMode(GL_PROJECTION);
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport matrix mode"); //ANDROID
+    #endif
     glLoadIdentity();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport load identity"); //ANDROID
+    #endif
 
     // 0,0 should be top left corner
     glOrtho(0, renderSize.x, renderSize.y, 0, -100, 100);
@@ -322,6 +401,9 @@
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Depthbuffer und Colorbuffer einstellen"); //ANDROID
+    #endif
     // Depthbuffer und Colorbuffer einstellen
     glClearColor(0.0, 0.0, 0.0, 1.0);
 
@@ -331,6 +413,9 @@
     glEnable(GL_ALPHA_TEST);
     glAlphaFunc(GL_GREATER, 0.0f);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Alphablending an"); //ANDROID
+    #endif
     // Alphablending an
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     glEnable(GL_BLEND);
@@ -348,12 +433,19 @@
     // Scissoring aktivieren
     glEnable(GL_SCISSOR_TEST);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Nur obere Seite von Dreiecke rendern --> Performance"); //ANDROID
+    #endif
     // Nur obere Seite von Dreiecke rendern --> Performance
     glEnable(GL_CULL_FACE);
 
     glEnableClientState(GL_VERTEX_ARRAY);
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport clearing screen"); //ANDROID
+    #endif
+
     ClearScreen();
 }
 
@@ -362,12 +454,38 @@
  */
 bool VideoDriverWrapper::LoadAllExtensions()
 {
+    #ifdef ANDROID
+    if(videodriver->IsOpenGL()) {
+        renderer_ = std::make_unique<OpenGLRenderer>();
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL wrapper"); //ANDROID
+    }
+    else{
+        renderer_ = std::make_unique<DummyRenderer>();
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions dummy wrapper"); //ANDROID
+    }
+    if(!renderer_->initOpenGL(videodriver->GetLoaderFunction())) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions renderer is not initopengl! error"); //ANDROID
+        return false;
+    }
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL supported!"); //ANDROID
+    LOG.write(_("OpenGL %1%.%2% supported\n")) % GLVersion.major % GLVersion.minor;
+    if(GLVersion.major < RTTR_OGL_MAJOR || (GLVersion.major == RTTR_OGL_MAJOR && GLVersion.minor < RTTR_OGL_MINOR))
+    {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL not supported try updating gpu drivers"); //ANDROID
+        LOG.write(_("OpenGL %1% %2%.%3% is not supported. Try updating your GPU drivers or hardware!"))
+          % ((RTTR_OGL_ES) ? "ES" : "") % RTTR_OGL_MAJOR % RTTR_OGL_MINOR;
+        return false;
+    }
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions auf vsync testen"); //ANDROID
+    #else
     if(videodriver->IsOpenGL())
         renderer_ = std::make_unique<OpenGLRenderer>();
     else
         renderer_ = std::make_unique<DummyRenderer>();
+    
     if(!renderer_->initOpenGL(videodriver->GetLoaderFunction()))
         return false;
+        
     LOG.write(_("OpenGL %1%.%2% supported\n")) % GLVersion.major % GLVersion.minor;
     if(GLVersion.major < RTTR_OGL_MAJOR || (GLVersion.major == RTTR_OGL_MAJOR && GLVersion.minor < RTTR_OGL_MINOR))
     {
@@ -375,6 +493,7 @@
           % ((RTTR_OGL_ES) ? "ES" : "") % RTTR_OGL_MAJOR % RTTR_OGL_MINOR;
         return false;
     }
+    #endif
 
 // auf VSync-Extension testen
 #ifdef _WIN32
@@ -383,6 +502,9 @@
     wglSwapIntervalEXT = reinterpret_cast<SwapIntervalExt_t*>(loadExtension("glXSwapIntervalSGI"));
 #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions returning true"); //ANDROID
+    #endif
     return true;
 }
 
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/network/GameClient.cpp s25client_patched/libs/s25main/network/GameClient.cpp
--- s25client/libs/s25main/network/GameClient.cpp	2025-06-14 12:48:51.380234502 +0200
+++ s25client_patched/libs/s25main/network/GameClient.cpp	2025-06-14 12:55:20.570137753 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "GameClient.h"
 #include "CreateServerInfo.h"
@@ -155,44 +158,81 @@
     SocketSet set;
 
     // erstmal auf Daten überprüfen
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run clear socketset"); //ANDROID
+    #endif
     set.Clear();
 
     // zum set hinzufügen
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run adding mainplayer to socket"); //ANDROID
+    #endif
     set.Add(mainPlayer.socket);
     if(set.Select(0, 0) > 0)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run mainplayer empfangen?"); //ANDROID
+        #endif
         // nachricht empfangen
         if(!mainPlayer.receiveMsgs())
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR GameClient::Run receiving message from server failed"); //ANDROID
+            #endif
             LOG.write("Receiving Message from server failed\n");
             ServerLost();
         }
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run suche nach fehlern"); //ANDROID
+    #endif
     // nun auf Fehler prüfen
     set.Clear();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run player zum socket hizufügen(wieder)"); //ANDROID
+    #endif
     // zum set hinzufügen
     set.Add(mainPlayer.socket);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run suche nach fehlern(2)"); //ANDROID
+    #endif
     // auf fehler prüfen
     if(set.Select(0, 2) > 0)
     {
         if(set.InSet(mainPlayer.socket))
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run Server weg(lost)"); //ANDROID
+            #endif
             // Server ist weg
             LOG.write("Error on socket to server\n");
             ServerLost();
         }
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run ist cflient loaded?"); //ANDROID
+    #endif
     if(state == ClientState::Loaded)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run yes"); //ANDROID
+        #endif
         // All players ready?
         if(nwfInfo->isReady())
             OnGameStart();
+    #ifdef ANDROID
+    } else if(state == ClientState::Game){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run executing game frame"); //ANDROID
+        ExecuteGameFrame();
+    }
+    #else
     } else if(state == ClientState::Game)
         ExecuteGameFrame();
+    #endif
 
     // maximal 10 Pakete verschicken
     mainPlayer.sendMsgs(10);
@@ -205,8 +245,16 @@
  */
 void GameClient::Stop()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Stop"); //ANDROID
+    if(state == ClientState::Stopped) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Stop client stopped. returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ClientState::Stopped)
         return;
+    #endif
 
     if(game)
         ExitGame();
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/network/GameServer.cpp s25client_patched/libs/s25main/network/GameServer.cpp
--- s25client/libs/s25main/network/GameServer.cpp	2025-06-14 12:47:11.016340324 +0200
+++ s25client_patched/libs/s25main/network/GameServer.cpp	2025-06-14 12:55:20.571096119 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "GameServer.h"
 #include "Debug.h"
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Settings.cpp s25client_patched/libs/s25main/Settings.cpp
--- s25client/libs/s25main/Settings.cpp	2025-06-14 12:48:51.377234505 +0200
+++ s25client_patched/libs/s25main/Settings.cpp	2025-06-14 12:55:20.571885790 +0200
@@ -73,7 +73,11 @@
     // 0 = ask user at start, 1 = enabled, 2 = always ask
     global.submit_debug_data = 0;
     global.use_upnp = false;
+    #ifdef ANDROID
+    global.smartCursor = false;
+    #else
     global.smartCursor = true;
+    #endif
     global.debugMode = false;
     global.showGFInfo = false;
     // }
@@ -139,7 +143,11 @@
     // interface
     // {
     interface.autosave_interval = 0;
+    #ifdef ANDROID
+    interface.invertMouse = true;
+    #else
     interface.invertMouse = false;
+    #endif
     interface.enableWindowPinning = false;
     interface.windowSnapDistance = 8;
     // }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/TerrainRenderer.cpp s25client_patched/libs/s25main/TerrainRenderer.cpp
--- s25client/libs/s25main/TerrainRenderer.cpp	2025-06-14 12:47:10.986340356 +0200
+++ s25client_patched/libs/s25main/TerrainRenderer.cpp	2025-06-14 12:57:15.454816561 +0200
@@ -225,7 +225,11 @@
             break;
         case Visibility::Visible:
             // Normal sichtbar
+            #ifdef ANDROID
+            GetVertex(pt).color = clr;
+            #else
             GetVertex(pt).color = clr / 2.f;
+            #endif
             break;
     }
 }
@@ -792,7 +796,12 @@
     }
 
     // Modulate2x
+    #ifdef ANDROID
+    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+    #else
     glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
+    #endif
+    
     glTexEnvf(GL_TEXTURE_ENV, GL_RGB_SCALE, 2.0f);
 
     // Disable alpha blending
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Window.cpp s25client_patched/libs/s25main/Window.cpp
--- s25client/libs/s25main/Window.cpp	2025-06-14 12:47:10.986340356 +0200
+++ s25client_patched/libs/s25main/Window.cpp	2025-06-14 12:55:20.572469045 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "Window.h"
 #include "CollisionDetection.h"
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/WindowManager.cpp s25client_patched/libs/s25main/WindowManager.cpp
--- s25client/libs/s25main/WindowManager.cpp	2025-06-14 12:47:10.987340355 +0200
+++ s25client_patched/libs/s25main/WindowManager.cpp	2025-06-14 12:55:20.573091765 +0200
@@ -1,7 +1,6 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
-
 #include "WindowManager.h"
 #include "CollisionDetection.h"
 #include "Loader.h"
@@ -356,6 +355,39 @@
 
     // Ggf. Doppelklick untersuche
     unsigned time_now = VIDEODRIVER.GetTickCount();
+    #ifdef ANDROID
+    if(time_now - lastLeftClickTime < DOUBLE_CLICK_INTERVAL)
+    {
+        if(!windows.empty()) {
+            IngameWindow* foundWindow = FindWindowAtPos(mc.GetPos());
+            if(windows.back()->IsModal()) {
+                // We have a modal window -> Activate it
+                SetActiveWindow(*windows.back());
+                // Ignore actions in all other windows
+                if(foundWindow != GetTopMostWindow())
+                    return;
+            }
+            if(foundWindow) {
+                // Close it if requested (unless pinned)
+                if(foundWindow->getCloseBehavior() == CloseBehavior::Regular) {
+                    if(!foundWindow->IsPinned())
+                        foundWindow->Close();
+                } else {
+                    SetActiveWindow(*foundWindow);
+                    //foundWindow->Msg_RightDown(mc);
+                }
+                return;
+            }
+        }
+        
+        mc.dbl_click = true;
+    } else
+    {
+        // Werte wieder erneut speichern
+        lastLeftClickPos = mc.GetPos();
+        lastLeftClickTime = time_now;
+    }
+    #else
     if(time_now - lastLeftClickTime < DOUBLE_CLICK_INTERVAL && mc.GetPos() == lastLeftClickPos)
     {
         mc.dbl_click = true;
@@ -365,6 +397,7 @@
         lastLeftClickPos = mc.GetPos();
         lastLeftClickTime = time_now;
     }
+    #endif
 
     // ist der Maus-Klick-Fix aktiv?
     if(!disable_mouse)
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/world/GameWorldView.cpp s25client_patched/libs/s25main/world/GameWorldView.cpp
--- s25client/libs/s25main/world/GameWorldView.cpp	2025-06-14 12:47:11.024513342 +0200
+++ s25client_patched/libs/s25main/world/GameWorldView.cpp	2025-06-14 12:55:20.573774489 +0200
@@ -117,6 +117,20 @@
     ObjectBetweenLines(noBase& obj, const DrawPoint& pos) : obj(obj), pos(pos) {}
 };
 
+#ifdef ANDROID
+Position GameWorldView::getWorldMousePos() {
+    Position mousePos = VIDEODRIVER.GetMousePos();
+    mousePos -= Position(origin_);
+    if(effectiveZoomFactor_ != 1.f) {
+        PointF diff(size_.x - size_.x / effectiveZoomFactor_, size_.y - size_.y / effectiveZoomFactor_);
+        diff = diff / 2.f;
+        mousePos = Position(PointF(mousePos) / effectiveZoomFactor_ + diff);
+    }
+    
+    return mousePos;
+}
+#endif
+
 void GameWorldView::Draw(const RoadBuildState& rb, const MapPoint selected, bool drawMouse, unsigned* water)
 {
     SetNextZoomFactor();
@@ -595,7 +609,7 @@
     other.show_productivity = show_productivity;
 }
 
-void GameWorldView::MoveBy(const DrawPoint& numPixels)
+void GameWorldView::MoveBy(const DrawPoint& numPixels) //android
 {
     MoveTo(offset + numPixels);
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/world/GameWorldView.h s25client_patched/libs/s25main/world/GameWorldView.h
--- s25client/libs/s25main/world/GameWorldView.h	2025-06-14 12:47:11.024513342 +0200
+++ s25client_patched/libs/s25main/world/GameWorldView.h	2025-06-14 12:55:20.574295807 +0200
@@ -70,6 +70,10 @@
 public:
     GameWorldView(const GameWorldViewer& gwv, const Position& pos, const Extent& size);
 
+    #ifdef ANDROID
+    Position getWorldMousePos();
+    #endif
+    
     const GameWorldViewer& GetViewer() const { return gwv; }
     const GameWorldBase& GetWorld() const;
     SoundManager& GetSoundMgr();
