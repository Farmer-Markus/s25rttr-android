diff -ruN --binary -x '.*' -x patched s25client/CMakeLists.txt s25client_patched/CMakeLists.txt
--- s25client/CMakeLists.txt	2024-09-09 22:27:18.785435000 +0200
+++ s25client_patched/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -22,9 +22,17 @@
     message(STATUS "Used Toolchain definition file '${CMAKE_TOOLCHAIN_FILE}'")
 endif()
 
-list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules" "${CMAKE_SOURCE_DIR}/external/libutil/cmake")
-if(CMAKE_VERSION VERSION_LESS 3.14)
-    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/external/libutil/cmake/cmake_3.14")
+
+if(ANDROID)
+    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/src/s25client/cmake/Modules" "${CMAKE_SOURCE_DIR}/src/s25client/external/libutil/cmake")
+    if(CMAKE_VERSION VERSION_LESS 3.14)
+        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/src/s25client/external/libutil/cmake/cmake_3.14")
+    endif()
+else()
+    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules" "${CMAKE_SOURCE_DIR}/external/libutil/cmake")
+    if(CMAKE_VERSION VERSION_LESS 3.14)
+        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/external/libutil/cmake/cmake_3.14")
+    endif()
 endif()
 
 include(EnableCCache)
@@ -274,6 +282,10 @@
     else()
         message(FATAL_ERROR "Unknown architecture for sizeof(void*)=${CMAKE_SIZEOF_VOID_P}")
     endif()
+elseif(ANDROID)
+    message(STATUS "Unofficial build with processor arch: ${CMAKE_SYSTEM_PROCESSOR}. Skipping release scripts and updater.")
+    unset(PLATFORM_ARCH)
+    set(RTTR_BUILD_UPDATER OFF CACHE INTERNAL "Disabled")
 else()
     if(${CMAKE_SYSTEM_PROCESSOR} MATCHES "i.86")
         set(PLATFORM_ARCH "i386")
@@ -300,7 +312,12 @@
     set(BOOST_ROOT ${rttrContribBoostDir} CACHE PATH "Path to find boost at")
 endif()
 
-set(BoostPackages filesystem iostreams locale program_options)
+if(ANDROID)
+    set(BoostPackages filesystem iostreams locale system thread program_options)
+else()
+    set(BoostPackages filesystem iostreams locale program_options)
+endif()
+
 if(BUILD_TESTING)
     # Avoid having to search for this in all tests speeding up configure
     list(APPEND BoostPackages unit_test_framework)
diff -ruN --binary -x '.*' -x patched s25client/external/CMakeLists.txt s25client_patched/external/CMakeLists.txt
--- s25client/external/CMakeLists.txt	2024-09-09 22:27:18.937439000 +0200
+++ s25client_patched/external/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -39,7 +39,11 @@
 add_subdirectory(libsiedler2)
 add_subdirectory(libutil)
 add_subdirectory(mygettext)
-add_subdirectory(s25edit)
+
+if(!ANDROID)
+    add_subdirectory(s25edit)
+endif()
+
 if(RTTR_BUILD_UPDATER)
     add_subdirectory(s25update)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/external/liblobby/CMakeLists.txt s25client_patched/external/liblobby/CMakeLists.txt
--- s25client/external/liblobby/CMakeLists.txt	2024-09-09 22:27:35.181845000 +0200
+++ s25client_patched/external/liblobby/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -20,7 +20,13 @@
 
 add_library(lobby STATIC EXCLUDE_FROM_ALL ${SOURCES_LOBBY})
 target_include_directories(lobby PUBLIC include)
-target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext)
+
+if(ANDROID)
+    target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext log)
+else()
+    target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext)
+endif()
+
 target_compile_features(lobby PUBLIC cxx_std_17)
 set_target_properties(lobby PROPERTIES CXX_EXTENSIONS OFF)
 
diff -ruN --binary -x '.*' -x patched s25client/external/liblobby/src/LobbyClient.cpp s25client_patched/external/liblobby/src/LobbyClient.cpp
--- s25client/external/liblobby/src/LobbyClient.cpp	2024-09-09 22:27:35.181845000 +0200
+++ s25client_patched/external/liblobby/src/LobbyClient.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -3,6 +3,9 @@
 //
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "liblobby/LobbyClient.h"
 #include "liblobby/LobbyInterface.h"
@@ -26,6 +29,9 @@
 
 LobbyClient::~LobbyClient()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::~LobbyClient() trennen von verbindung zum server"); //ANDROID
+    #endif
     Stop();
 }
 
@@ -45,12 +51,25 @@
  */
 void LobbyClient::Run()
 {
-    if(state == CS_STOPPED)
+    #ifdef ANDROID
+    if(state == CS_STOPPED) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run() lobbyclient state is stopped returning"); //ANDROID
         return;
+    }
+    #else
+    if(state == CS_STOPPED)
+    return;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run()"); //ANDROID
+    #endif
     // nachrichten empfangen
     if(recv_queue.recvAll(socket) < 0)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run()"); //ANDROID
+        #endif
         LOG.write("Receiving Message from server failed\n");
         ServerLost();
         return;
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/cmake/cmake_3.14/FindBoost.cmake s25client_patched/external/libutil/cmake/cmake_3.14/FindBoost.cmake
--- s25client/external/libutil/cmake/cmake_3.14/FindBoost.cmake	2024-09-09 22:27:35.221846000 +0200
+++ s25client_patched/external/libutil/cmake/cmake_3.14/FindBoost.cmake	2024-09-14 18:03:28.605406000 +0200
@@ -283,6 +283,7 @@
 endif()
 
 
+
 #-------------------------------------------------------------------------------
 #  FindBoost functions & macros
 #
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/cmake/FindMiniupnpc.cmake s25client_patched/external/libutil/cmake/FindMiniupnpc.cmake
--- s25client/external/libutil/cmake/FindMiniupnpc.cmake	2024-09-09 22:27:35.221846000 +0200
+++ s25client_patched/external/libutil/cmake/FindMiniupnpc.cmake	2024-09-14 18:03:28.605406000 +0200
@@ -9,6 +9,7 @@
 #  MINIUPNPC_LIBRARY     - Library to link to libminiupnpc.
 #  MINIUPNPC_FOUND       - True if libminiupnpc found.
 
+
 FIND_PATH(MINIUPNPC_INCLUDE_DIR NAMES miniupnpc/miniupnpc.h PATHS
 	${MINIUPNPC_DIR_SEARCH}/miniupnpc/include
 	/usr/include
@@ -21,6 +22,7 @@
 	/usr/local/lib
 )
 
+
 INCLUDE(FindPackageHandleStandardArgs)
 FIND_PACKAGE_HANDLE_STANDARD_ARGS(Miniupnpc DEFAULT_MSG MINIUPNPC_INCLUDE_DIR MINIUPNPC_LIBRARY)
 
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/libs/common/CMakeLists.txt s25client_patched/external/libutil/libs/common/CMakeLists.txt
--- s25client/external/libutil/libs/common/CMakeLists.txt	2024-09-09 22:27:35.221846000 +0200
+++ s25client_patched/external/libutil/libs/common/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -2,6 +2,10 @@
 #
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+if(ANDROID)
+    find_library(SDL2 SDL2) #ANDROID
+endif()
+
 set(_BoostComponents filesystem)
 if(WIN32)
     # Locale only on windows
@@ -19,7 +23,13 @@
 add_library(s25util::common ALIAS s25util_common)
 
 target_include_directories(s25util_common PUBLIC include PRIVATE include/s25util)
-target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem)
+
+if(ANDROID)
+    target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem SDL2)
+else()
+    target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem)
+endif()
+
 target_compile_features(s25util_common PUBLIC cxx_std_17)
 # PIC Required for linking into shared libs
 set_target_properties(s25util_common PROPERTIES CXX_EXTENSIONS OFF POSITION_INDEPENDENT_CODE ON)
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/libs/common/src/System_Other.cpp s25client_patched/external/libutil/libs/common/src/System_Other.cpp
--- s25client/external/libutil/libs/common/src/System_Other.cpp	2024-09-09 22:27:35.225846000 +0200
+++ s25client_patched/external/libutil/libs/common/src/System_Other.cpp	2024-09-16 16:31:11.692303000 +0200
@@ -2,9 +2,14 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
 #include "System.h"
 #include <stdexcept>
 
+
 boost::filesystem::path System::getHomePath()
 {
     boost::filesystem::path homePath = getPathFromEnvVar("HOME");
@@ -17,9 +22,14 @@
     return homePath;
 }
 
+
 std::string System::getUserName()
 {
+    #ifdef ANDROID
+    std::string name = "android";
+    #else
     std::string name = getEnvVar("USER");
+    #endif
     if(name.empty())
         throw std::runtime_error("Could not get username");
     return name;
diff -ruN --binary -x '.*' -x patched s25client/extras/ai-battle/CMakeLists.txt s25client_patched/extras/ai-battle/CMakeLists.txt
--- s25client/extras/ai-battle/CMakeLists.txt	2024-09-09 22:27:18.937439000 +0200
+++ s25client_patched/extras/ai-battle/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -2,7 +2,12 @@
 #
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+if(ANDROID)
+add_library(ai-battle main.cpp HeadlessGame.cpp)
+else()
 add_executable(ai-battle main.cpp HeadlessGame.cpp)
+endif()
+
 target_link_libraries(ai-battle PRIVATE s25Main Boost::program_options Boost::nowide)
 
 if(WIN32)
diff -ruN --binary -x '.*' -x patched s25client/extras/audioDrivers/SDL/CMakeLists.txt s25client_patched/extras/audioDrivers/SDL/CMakeLists.txt
--- s25client/extras/audioDrivers/SDL/CMakeLists.txt	2024-09-09 22:27:18.937439000 +0200
+++ s25client_patched/extras/audioDrivers/SDL/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -20,9 +20,11 @@
     target_link_libraries(audioSDL PRIVATE audiodrv SDL_mixer::SDL_mixer)
     enable_warnings(audioSDL)
 
-    install(TARGETS audioSDL
-      RUNTIME DESTINATION ${RTTR_DRIVERDIR}/audio
-      LIBRARY DESTINATION ${RTTR_DRIVERDIR}/audio
-    )
+    if(!ANDROID)
+        install(TARGETS audioSDL
+          RUNTIME DESTINATION ${RTTR_DRIVERDIR}/audio
+          LIBRARY DESTINATION ${RTTR_DRIVERDIR}/audio
+        )
+    endif()
     add_dependencies(drivers audioSDL)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/CMakeLists.txt s25client_patched/extras/videoDrivers/SDL2/CMakeLists.txt
--- s25client/extras/videoDrivers/SDL2/CMakeLists.txt	2024-09-09 22:27:18.941439000 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -7,7 +7,13 @@
 
 if(SDL2_FOUND)
     add_library(videoSDL2 SHARED ${RTTR_DRIVER_INTERFACE} VideoSDL2.cpp VideoSDL2.h icon.h icon.cpp)
-    target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2)
+    
+    if(ANDROID)
+        target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2 log GL)
+    else()
+        target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2)
+    endif()
+    
     enable_warnings(videoSDL2)
 
     if(WIN32)
@@ -15,9 +21,11 @@
         gather_dll_by_name(SDL2 SDL2.dll)
     endif()
 
-    install(TARGETS videoSDL2
-      RUNTIME DESTINATION ${RTTR_DRIVERDIR}/video
-      LIBRARY DESTINATION ${RTTR_DRIVERDIR}/video
-    )
+    if (!ANDROID)
+        install(TARGETS videoSDL2
+          RUNTIME DESTINATION ${RTTR_DRIVERDIR}/video
+          LIBRARY DESTINATION ${RTTR_DRIVERDIR}/video
+        )
+    endif()
     add_dependencies(drivers videoSDL2)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/VideoSDL2.cpp s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.cpp
--- s25client/extras/videoDrivers/SDL2/VideoSDL2.cpp	2024-09-09 22:27:18.941439000 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -2,6 +2,11 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#include <gl4esinit.h>
+#endif
+
 #include "VideoSDL2.h"
 #include "driver/Interface.h"
 #include "driver/VideoDriverLoaderInterface.h"
@@ -109,6 +114,9 @@
 
 bool VideoSDL2::CreateScreen(const std::string& title, const VideoMode& size, bool fullscreen)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoSDL2::CreateScreen initialized? %d", initialized); //ANDROID
+    #endif
     if(!initialized)
         return false;
 
@@ -117,11 +125,16 @@
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RTTR_OGL_MINOR));
     SDL_GLprofile profile;
     if((RTTR_OGL_ES))
-        profile = SDL_GL_CONTEXT_PROFILE_ES;
+	profile = SDL_GL_CONTEXT_PROFILE_ES;
     else if((RTTR_OGL_COMPAT))
         profile = SDL_GL_CONTEXT_PROFILE_COMPATIBILITY;
     else
         profile = SDL_GL_CONTEXT_PROFILE_CORE;
+
+    #ifdef ANDROID
+    profile = SDL_GL_CONTEXT_PROFILE_ES;
+    #endif
+    
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile));
 
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8));
@@ -129,7 +142,11 @@
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8));
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1));
 
+    #ifdef ANDROID
+    int wndPos = SDL_WINDOWPOS_UNDEFINED;
+    #else
     int wndPos = SDL_WINDOWPOS_CENTERED;
+    #endif
 
     const auto requestedSize = fullscreen ? FindClosestVideoMode(size) : size;
     unsigned commonFlags = SDL_WINDOW_OPENGL;
@@ -166,7 +183,7 @@
     {
         SDL_SetWindowIcon(window, iconSurf);
         SDL_FreeSurface(iconSurf);
-    } else
+    } else 
         PrintError(SDL_GetError());
 
     context = SDL_GL_CreateContext(window);
@@ -437,7 +454,11 @@
 
 OpenGL_Loader_Proc VideoSDL2::GetLoaderFunction() const
 {
+    #ifdef ANDROID
+    return gl4es_GetProcAddress;
+    #else
     return SDL_GL_GetProcAddress;
+    #endif
 }
 
 void VideoSDL2::SetMousePos(Position pos)
diff -ruN --binary -x '.*' -x patched s25client/libs/rttrConfig/CMakeLists.txt s25client_patched/libs/rttrConfig/CMakeLists.txt
--- s25client/libs/rttrConfig/CMakeLists.txt	2024-09-09 22:27:18.945439000 +0200
+++ s25client_patched/libs/rttrConfig/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -10,10 +10,19 @@
   src/RttrConfig.h
 )
 target_include_directories(rttrConfig INTERFACE src)
-target_link_libraries(rttrConfig
-    PUBLIC s25util::common Boost::filesystem
-    PRIVATE s25Common
-)
+
+if(ANDROID)
+    target_link_libraries(rttrConfig
+        PUBLIC s25util::common Boost::filesystem log
+        PRIVATE s25Common
+    )
+else()
+    target_link_libraries(rttrConfig
+        PUBLIC s25util::common Boost::filesystem
+        PRIVATE s25Common
+    )
+endif()
+
 set_property(TARGET rttrConfig PROPERTY POSITION_INDEPENDENT_CODE ON)
 
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/build_paths.h.cmake build_paths.h @ONLY)
diff -ruN --binary -x '.*' -x patched s25client/libs/rttrConfig/src/RttrConfig.cpp s25client_patched/libs/rttrConfig/src/RttrConfig.cpp
--- s25client/libs/rttrConfig/src/RttrConfig.cpp	2024-09-09 22:27:18.945439000 +0200
+++ s25client_patched/libs/rttrConfig/src/RttrConfig.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -2,6 +2,10 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
 #include "RttrConfig.h"
 #include "RTTR_Assert.h"
 #include "s25util/Log.h"
@@ -33,9 +37,15 @@
 
 bfs::path RttrConfig::GetPrefixPath()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::getPrefixPath() need to get prefix path"); //ANDROID
+    #endif
     // Determine install prefix
     // Get path to current executable (at least for checks)
     bfs::path fullExeFilepath = System::getExecutablePath();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::getPrefixPath() executablePath %s", fullExeFilepath.c_str()); //ANDROID
+    #endif
     // This should always work unless we have some missing implementation or a bad error
     if(fullExeFilepath.empty())
     {
@@ -89,22 +99,59 @@
 
 boost::filesystem::path RttrConfig::ExpandPath(const std::string& path) const
 {
-    if(path.empty())
+    #ifdef ANDROID
+    if(path.empty()) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  path is empty using prefixPath"); //ANDROID
+        return prefixPath_;
+    }
+    #else
+        if(path.empty())
         return prefixPath_;
+    #endif
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  expanding path: %s", path.c_str()); //ANDROID
+    #endif
+    
     bfs::path outPath;
     if(path[0] == '<')
     {
         static const char rttrPathId[] = "<RTTR_";
         size_t startPos = path.find(rttrPathId);
+
+        #ifdef ANDROID
+        if(startPos > 0u) {
+            throw std::runtime_error("<RTTR_X> placeholders only allowed at start of path");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  <RTTR_X> placeholders only allowed at start of path"); //ANDROID
+        }
+        #else
         if(startPos > 0u)
             throw std::runtime_error("<RTTR_X> placeholders only allowed at start of path");
+        #endif
+
         size_t endPos = path.find('>');
-        if(endPos == std::string::npos)
+        #ifdef ANDROID
+        if(endPos == std::string::npos) {
             throw std::runtime_error("Incomplete <RTTR_X> placeholder found!");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  Incomplete <RTTR_X> placeholder found!"); //ANDROID
+        }
+        #else
+        if(endPos == std::string::npos)
+        throw std::runtime_error("Incomplete <RTTR_X> placeholder found!");
+        #endif
+
         std::string entry = path.substr(sizeof(rttrPathId) - 1, endPos - startPos - sizeof(rttrPathId) + 1);
         auto it = pathMappings.find(entry);
-        if(it == pathMappings.end())
+        #ifdef ANDROID
+        if(it == pathMappings.end()) {
             throw std::runtime_error("Invalid <RTTR_X> placeholder found!");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  Invalid <RTTR_X> placeholder found!"); //ANDROID
+        }
+        #else
+        if(it == pathMappings.end())
+        throw std::runtime_error("Invalid <RTTR_X> placeholder found!");
+        #endif
+
         outPath = bfs::path(it->second) / path.substr(endPos + 1);
     } else
         outPath = path;
@@ -112,6 +159,9 @@
         outPath = homePath / outPath.string().substr(2);
 
     outPath = bfs::absolute(outPath, prefixPath_).lexically_normal();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath returning path: %s", outPath.c_str()); //ANDROID
+    #endif
     return outPath.make_preferred();
 }
 
@@ -123,7 +173,11 @@
 
 bool RttrConfig::Init()
 {
+    #ifdef ANDROID
+    prefixPath_ = System::getHomePath();
+    #else
     prefixPath_ = GetPrefixPath();
+    #endif
     if(prefixPath_.empty())
         return false;
     // Make the prefix path our working directory as all other paths are relative to that
diff -ruN --binary -x '.*' -x patched s25client/libs/s25client/CMakeLists.txt s25client_patched/libs/s25client/CMakeLists.txt
--- s25client/libs/s25client/CMakeLists.txt	2024-09-09 22:27:18.945439000 +0200
+++ s25client_patched/libs/s25client/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -18,9 +18,16 @@
     set(s25client_RC )
 endif()
 
-add_executable(s25client s25client.cpp commands.cpp ${s25client_RC})
-target_link_libraries(s25client PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld)
-add_dependencies(s25client drivers)
+if(ANDROID)
+    add_library(main SHARED s25client.cpp commands.cpp ${s25client_RC})
+    target_link_libraries(main PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld log)
+    add_dependencies(main drivers)
+else()
+    add_executable(s25client s25client.cpp commands.cpp ${s25client_RC})
+    target_link_libraries(s25client PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld)
+    add_dependencies(s25client drivers)
+endif()
+
 
 if(WIN32)
     target_include_directories(s25client PRIVATE ${rcDir})
@@ -46,4 +53,6 @@
     gather_dll_copy(s25client)
 endif()
 
-INSTALL(TARGETS s25client RUNTIME DESTINATION ${RTTR_BINDIR})
+if(NOT ANDROID)
+    INSTALL(TARGETS s25client RUNTIME DESTINATION ${RTTR_BINDIR})
+endif()
diff -ruN --binary -x '.*' -x patched s25client/libs/s25client/s25client.cpp s25client_patched/libs/s25client/s25client.cpp
--- s25client/libs/s25client/s25client.cpp	2024-09-09 22:27:18.945439000 +0200
+++ s25client_patched/libs/s25client/s25client.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -1,6 +1,10 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <SDL.h>
+#include <android/log.h>
+#endif
 
 #include "Debug.h"
 #include "GameManager.h"
@@ -85,6 +89,9 @@
     if(waited)
         return;
     waited = true;
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Press ENTER to close this window . . ."); //ANDROID
+    #endif
     bnw::cout << "\n\nPress ENTER to close this window . . ." << std::endl;
     bnw::cin.clear();
     bnw::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
@@ -142,6 +149,9 @@
 
 void showCrashMessage()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttR crashed. Please restart the application!"); //ANDROID
+    #endif
     std::string text = gettext_noop("RttR crashed. Please restart the application!");
     std::string errorTxt = gettext_noop("Error");
     try
@@ -363,6 +373,9 @@
 
 bool InitDirectories()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() funktion"); //ANDROID
+    #endif
     // Note: Do not use logger yet. Filepath may not exist
     const auto curPath = bfs::current_path();
     LOG.write("Starting in %1%\n", LogTarget::Stdout) % curPath;
@@ -370,14 +383,30 @@
     if(!MigrateFilesAndDirectories())
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Creating all folders"); //ANDROID
+    #endif
     // Create all required/useful folders
     const std::array<std::string, 10> dirs = {
       {s25::folders::config, s25::folders::logs, s25::folders::mapsOwn, s25::folders::mapsPlayed, s25::folders::replays,
        s25::folders::save, s25::folders::assetsUserOverrides, s25::folders::screenshots, s25::folders::playlists}};
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() done creating folders"); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() s25::folders::config %s", s25::folders::config  ); //ANDROID
+    #endif
 
     for(const std::string& rawDir : dirs)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() %s", rawDir.c_str()); //ANDROID
+        #endif
         const bfs::path dir = RTTRCONFIG.ExpandPath(rawDir);
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() %s", dir.c_str()); //ANDROID
+        #endif
         boost::system::error_code ec;
         bfs::create_directories(dir, ec);
         if(ec != boost::system::errc::success)
@@ -386,6 +415,9 @@
             // Make sure we catch that
             try
             {
+                #ifdef ANDROID
+                __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() folders could not be created"); //ANDROID
+                #endif
                 s25util::error(std::string("Directory ") + dir.string() + " could not be created.");
                 s25util::error("Failed to start the game");
             } catch(const std::runtime_error& error)
@@ -395,10 +427,16 @@
             return false;
         }
     }
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Writing log: Directory for user data (config etc.):"); //ANDROID
+    #endif
     LOG.write("Directory for user data (config etc.): %1%\n", LogTarget::Stdout)
       % RTTRCONFIG.ExpandPath(s25::folders::config);
 
     // Write this to file too, after folders are created
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() set log filepath"); //ANDROID
+    #endif
     LOG.setLogFilepath(RTTRCONFIG.ExpandPath(s25::folders::logs));
     try
     {
@@ -407,15 +445,24 @@
         LOG.write("Starting in %1%\n", LogTarget::File) % curPath;
     } catch(const std::exception& e)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Error initializing log: \n" ); //ANDROID
+        #endif
         LOG.write("Error initializing log: %1%\nSystem reports: %2%\n", LogTarget::Stderr) % e.what()
           % LOG.getLastError();
         return false;
     }
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Returning TRUE"); //ANDROID
+    #endif
     return true;
 }
 
 bool InitGame(GameManager& gameManager)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitGame Funktion"); //ANDROID
+    #endif
     libsiedler2::setAllocator(new GlAllocator());
 
     // Socketzeug initialisieren
@@ -425,10 +472,16 @@
         s25util::error("Failed to start the game");
         return false;
     }
-
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "SPIEL STARTEN!!"); //ANDROID
+    #endif
     // Spiel starten
     if(!gameManager.Start())
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Failed to start the game"); //ANDROID
+        #endif
         s25util::error("Failed to start the game");
         return false;
     }
@@ -450,6 +503,9 @@
         return 1;
 
     // Zufallsgenerator initialisieren (Achtung: nur für Animations-Offsets interessant, für alles andere
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Directories created successfully!"); //ANDROID
+    #endif
     // (spielentscheidende) wird unser Generator verwendet)
     srand(static_cast<unsigned>(std::time(nullptr)));
 
@@ -457,10 +513,16 @@
     {
         try
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Convert sounds"); //ANDROID
+            #endif
             convertAndSaveSounds(RTTRCONFIG, RTTRCONFIG.ExpandPath("<RTTR_USERDATA>/convertedSoundeffects"));
             return 0;
         } catch(const std::runtime_error& e)
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Error: %s", e.what()); //ANDROID
+            #endif
             bnw::cerr << "Error: " << e.what() << "\n";
             return 1;
         }
@@ -470,6 +532,9 @@
                                                       WINDOWMANAGER);
     try
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() running initgame(gamemanager)"); //ANDROID
+        #endif
         if(!InitGame(gameManager))
             return 2;
 
@@ -484,6 +549,10 @@
         }
 
         // Hauptschleife
+        
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Hauptschleife..."); //ANDROID
+        #endif
 
         while(gameManager.Run())
         {
@@ -492,6 +561,10 @@
 #endif // !_WIN32
         }
 
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Killing game"); //ANDROID
+        #endif
+
         // Spiel beenden
         gameManager.Stop();
         libsiedler2::setAllocator(nullptr);
@@ -522,6 +595,15 @@
 // NOLINTNEXTLINE(bugprone-exception-escape)
 int main(int argc, char** argv)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Starting Main function, %s", SDL_AndroidGetInternalStoragePath()); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
+    SDL_SetHint(SDL_HINT_TOUCH_MOUSE_EVENTS, "1");  // Converts touch events to mouse events
+    SDL_SetHint(SDL_HINT_MOUSE_TOUCH_EVENTS, "0");  // Converts mouse events to touch events
+    #endif
+
     bnw::args _(argc, argv);
 
     po::options_description desc("Allowed options");
@@ -570,11 +652,17 @@
         result = e.code;
     } catch(const std::exception& e)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "An exception occurred: %s", e.what()); //ANDROID
+        #endif
         bnw::cerr << "An exception occurred: " << e.what() << "\n\n";
         handleException(nullptr);
         result = 1;
     } catch(...)
     {
+               #ifdef ANDROID
+               __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "An unknown exception occurred!"); //ANDROID
+               #endif
         bnw::cerr << "An unknown exception occurred\n";
         handleException(nullptr);
         result = 1;
@@ -582,5 +670,8 @@
     if(result)
         WaitForEnter();
 
+    #ifdef ANDROID
+    exit(result); //to full close android app
+    #endif
     return result;
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/CMakeLists.txt s25client_patched/libs/s25main/CMakeLists.txt
--- s25client/libs/s25main/CMakeLists.txt	2024-09-09 22:27:18.945439000 +0200
+++ s25client_patched/libs/s25main/CMakeLists.txt	2024-09-14 18:03:28.605406000 +0200
@@ -50,20 +50,37 @@
 set_target_properties(s25Main PROPERTIES CXX_EXTENSIONS OFF)
 target_compile_features(s25Main PUBLIC cxx_std_17)
 
-target_link_libraries(s25Main PUBLIC
-    siedler2
-    lobby_c
-    s25util::common
-    s25util::network
-    mygettext
-    s25Common
-    rttrConfig
-    gamedata
-    glad
-    driver
-    Boost::filesystem Boost::disable_autolinking
-    PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::nowide samplerate_cpp
+if(ANDROID)
+    target_link_libraries(s25Main PUBLIC
+        siedler2
+        lobby_c
+        s25util::common
+        s25util::network
+        mygettext
+        s25Common
+        rttrConfig
+        gamedata
+        glad
+        driver
+        Boost::filesystem Boost::disable_autolinking
+        PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::system Boost::thread Boost::nowide samplerate_cpp log iconv
 )
+else()
+    target_link_libraries(s25Main PUBLIC
+        siedler2
+        lobby_c
+        s25util::common
+        s25util::network
+        mygettext
+        s25Common
+        rttrConfig
+        gamedata
+        glad
+        driver
+        Boost::filesystem Boost::disable_autolinking
+        PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::system Boost::thread Boost::nowide samplerate_cpp
+)
+endif()
 
 if(WIN32)
     include(CheckIncludeFiles)
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Debug.cpp s25client_patched/libs/s25main/Debug.cpp
--- s25client/libs/s25main/Debug.cpp	2024-09-09 22:27:18.945439000 +0200
+++ s25client_patched/libs/s25main/Debug.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -149,8 +149,13 @@
 #else
 void captureBacktrace(std::vector<void*>& stacktrace) noexcept
 {
+    #ifdef ANDROID
+    (void)stacktrace; // stacktrace not available on android...
+    return;
+    #else
     unsigned num_frames = backtrace(&stacktrace[0], stacktrace.size());
     stacktrace.resize(num_frames);
+    #endif
 }
 #endif
 } // namespace
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/drivers/DriverWrapper.cpp s25client_patched/libs/s25main/drivers/DriverWrapper.cpp
--- s25client/libs/s25main/drivers/DriverWrapper.cpp	2024-09-09 22:27:18.961439000 +0200
+++ s25client_patched/libs/s25main/drivers/DriverWrapper.cpp	2024-09-16 16:30:07.778019000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "DriverWrapper.h"
 #include "ListDir.h"
@@ -44,17 +47,37 @@
 bool DriverWrapper::Load(const DriverType dt, std::string& preference)
 {
     // ggf. aufräumen vorher
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() unloading driver(if needed) "); //ANDROID
+    #endif
     Unload();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() driver unloaded "); //ANDROID
+    #endif
+
     /// Verfügbare Treiber auflisten
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() list drivers "); //ANDROID
+    #endif
     std::vector<DriverItem> drivers = LoadDriverList(dt);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() writing to log what drivers are found "); //ANDROID
+    #endif
     LOG.write("%u %s drivers found!\n") % drivers.size() % getName(dt);
 
     // Welche gefunden?
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() treiber gefunden? "); //ANDROID
+    #endif
     if(drivers.empty())
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() Ja treiber gefunden "); //ANDROID
+    #endif
+
     /// Suche, ob der Treiber dabei ist, den wir wünschen
     const auto it = helpers::find_if(drivers, [preference](const auto& it) { return it.GetName() == preference; });
     if(it != drivers.end())
@@ -129,11 +152,22 @@
     return true;
 }
 
+
 std::vector<DriverWrapper::DriverItem> DriverWrapper::LoadDriverList(const DriverType dt)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers"); //ANDROID
+    #endif
     std::vector<DriverItem> driver_list;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers"); //ANDROID
+    #endif
+    #ifdef ANDROID
+    const bfs::path& driverDir = getenv("libDir") + getName(dt);
+    #else
     const auto driverDir = RTTRCONFIG.ExpandPath(s25::folders::driver) / getName(dt);
+    #endif
     std::string extension =
 #ifdef _WIN32
       "dll";
@@ -145,6 +179,9 @@
 #    endif // !__APPLE__
 #endif     // !_WIN32
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers in %s", driverDir.c_str()); //ANDROID
+    #endif
     LOG.write(_("Searching for drivers in %s\n")) % driverDir;
     const std::vector<boost::filesystem::path> driver_files = ListDir(driverDir, extension, false);
 
@@ -166,10 +203,21 @@
             continue;
 #endif
         std::string nameOrError;
+        #ifdef ANDROID
+        if(!CheckLibrary(path, dt, nameOrError)) {
+            LOG.write(_("Skipping %s: %s\n")) % path % nameOrError;
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() Skipping %s: %s",path.c_str(), nameOrError.c_str()); //ANDROID
+        }
+        else {
+            driver_list.push_back(DriverItem(path, nameOrError));
+             __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() error else %s", nameOrError.c_str()); //ANDROID
+        }
+        #else
         if(!CheckLibrary(path, dt, nameOrError))
             LOG.write(_("Skipping %s: %s\n")) % path % nameOrError;
         else
             driver_list.push_back(DriverItem(path, nameOrError));
+        #endif
     }
     return driver_list;
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/drivers/VideoDriverWrapper.cpp s25client_patched/libs/s25main/drivers/VideoDriverWrapper.cpp
--- s25client/libs/s25main/drivers/VideoDriverWrapper.cpp	2024-09-09 22:27:18.961439000 +0200
+++ s25client_patched/libs/s25main/drivers/VideoDriverWrapper.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "VideoDriverWrapper.h"
 #include "FrameCounter.h"
@@ -35,10 +38,18 @@
 
 VideoDriverWrapper::~VideoDriverWrapper()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::~VideoDriverWrapper()  cleanup"); //ANDROID
+    #endif
     CleanUp();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::~VideoDriverWrapper()  unload driver"); //ANDROID
+    #endif
     UnloadDriver();
 }
 
+void initialize_gl4es();
+
 bool VideoDriverWrapper::Initialize()
 {
     if(!videodriver || !videodriver->Initialize())
@@ -57,18 +68,36 @@
 
 bool VideoDriverWrapper::LoadDriver(IVideoDriver* existingDriver)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver() unloading driver"); //ANDROID
+    #endif
     UnloadDriver();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver() initialize ivideodriver"); //ANDROID
+    #endif
     videodriver = Handle(existingDriver, [](IVideoDriver* p) { delete p; });
     return Initialize();
 }
 
 bool VideoDriverWrapper::LoadDriver(std::string& preference)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() unload driver "); //ANDROID
+    #endif
     UnloadDriver();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() driver unloaded "); //ANDROID
+    #endif
     // DLL laden
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() load driver video "); //ANDROID
+    #endif
     if(!driver_wrapper.Load(drivers::DriverType::Video, preference))
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() driver loaded "); //ANDROID
+    #endif
     auto createVideoInstance = driver_wrapper.GetFunction<CreateVideoInstance_t>("CreateVideoInstance");
     auto freeVideoInstance = driver_wrapper.GetFunction<FreeVideoInstance_t>("FreeVideoInstance");
     RTTR_Assert(createVideoInstance && freeVideoInstance);
@@ -96,32 +125,60 @@
 {
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
 
     if(!videodriver->CreateScreen(rttr::version::GetTitle(), size, fullscreen))
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Could not create window!"); //ANDROID
+        #endif
         s25util::fatal_error("Could not create window!");
         return false;
     }
-
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Window created"); //ANDROID
+    #endif
+
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen loading extensions"); //ANDROID
+    #endif
     // DriverWrapper Initialisieren
     // Extensions laden
     if(!LoadAllExtensions())
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen ERROR! failed to initialize the opengl context!"); //ANDROID
+        #endif
         s25util::fatal_error("Failed to initialize the OpenGL context!");
         return false;
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Renew Viewport..."); //ANDROID
+    #endif
     RenewViewport();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Swapping buffers"); //ANDROID
+    #endif
     // Buffer swappen um den leeren Buffer darzustellen
     SwapBuffers();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen windowmanager msg screenresize(getrendersize())"); //ANDROID
+    #endif
     // WindowManager informieren
     WINDOWMANAGER.Msg_ScreenResize(GetRenderSize());
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen returning true"); //ANDROID
+    #endif
+
     return true;
 }
 
@@ -136,8 +193,15 @@
  */
 bool VideoDriverWrapper::ResizeScreen(const VideoMode size, const bool fullscreen)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ResizeScreen"); //ANDROID
+    #endif
+    
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ResizeScreen No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
@@ -257,8 +321,14 @@
 
 void VideoDriverWrapper::SwapBuffers()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::SwapBuffers()"); //ANDROID
+    #endif
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR VideoDriverWrapper::SwapBuffers() No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return;
     }
@@ -271,17 +341,26 @@
 
 void VideoDriverWrapper::ClearScreen()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ClearScreen"); //ANDROID
     glClear(GL_COLOR_BUFFER_BIT);
+    #endif
 }
 
 bool VideoDriverWrapper::Run()
 {
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR VideoDriverWrapper::Run No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "INFO VideoDriverWrapper::Run returning videodriver->MessageLoop()"); //ANDROID
+    #endif
     return videodriver->MessageLoop();
 }
 
@@ -302,9 +381,15 @@
  */
 void VideoDriverWrapper::RenewViewport()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport"); //ANDROID
+    #endif
     if(!videodriver->IsOpenGL() || !renderer_)
         return;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport is video driver not opengl"); //ANDROID
+    #endif
     const Extent renderSize = videodriver->GetRenderSize();
     const VideoMode windowSize = videodriver->GetWindowSize();
 
@@ -312,9 +397,18 @@
     glViewport(0, 0, windowSize.width, windowSize.height);
     glScissor(0, 0, windowSize.width, windowSize.height);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Orthogonale Matrix erstellen"); //ANDROID
+    #endif
     // Orthogonale Matrix erstellen
     glMatrixMode(GL_PROJECTION);
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport matrix mode"); //ANDROID
+    #endif
     glLoadIdentity();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport load identity"); //ANDROID
+    #endif
 
     // 0,0 should be top left corner
     glOrtho(0, renderSize.x, renderSize.y, 0, -100, 100);
@@ -322,6 +416,9 @@
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Depthbuffer und Colorbuffer einstellen"); //ANDROID
+    #endif
     // Depthbuffer und Colorbuffer einstellen
     glClearColor(0.0, 0.0, 0.0, 1.0);
 
@@ -331,6 +428,9 @@
     glEnable(GL_ALPHA_TEST);
     glAlphaFunc(GL_GREATER, 0.0f);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Alphablending an"); //ANDROID
+    #endif
     // Alphablending an
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     glEnable(GL_BLEND);
@@ -348,12 +448,19 @@
     // Scissoring aktivieren
     glEnable(GL_SCISSOR_TEST);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Nur obere Seite von Dreiecke rendern --> Performance"); //ANDROID
+    #endif
     // Nur obere Seite von Dreiecke rendern --> Performance
     glEnable(GL_CULL_FACE);
 
     glEnableClientState(GL_VERTEX_ARRAY);
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport clearing screen"); //ANDROID
+    #endif
+
     ClearScreen();
 }
 
@@ -362,12 +469,38 @@
  */
 bool VideoDriverWrapper::LoadAllExtensions()
 {
+    #ifdef ANDROID
+    if(videodriver->IsOpenGL()) {
+        renderer_ = std::make_unique<OpenGLRenderer>();
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL wrapper"); //ANDROID
+    }
+    else{
+        renderer_ = std::make_unique<DummyRenderer>();
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions dummy wrapper"); //ANDROID
+    }
+    if(!renderer_->initOpenGL(videodriver->GetLoaderFunction())) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions renderer is not initopengl! error"); //ANDROID
+        return false;
+    }
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL supported!"); //ANDROID
+    LOG.write(_("OpenGL %1%.%2% supported\n")) % GLVersion.major % GLVersion.minor;
+    if(GLVersion.major < RTTR_OGL_MAJOR || (GLVersion.major == RTTR_OGL_MAJOR && GLVersion.minor < RTTR_OGL_MINOR))
+    {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL not supported try updating gpu drivers"); //ANDROID
+        LOG.write(_("OpenGL %1% %2%.%3% is not supported. Try updating your GPU drivers or hardware!"))
+          % ((RTTR_OGL_ES) ? "ES" : "") % RTTR_OGL_MAJOR % RTTR_OGL_MINOR;
+        return false;
+    }
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions auf vsync testen"); //ANDROID
+    #else
     if(videodriver->IsOpenGL())
         renderer_ = std::make_unique<OpenGLRenderer>();
     else
         renderer_ = std::make_unique<DummyRenderer>();
+    
     if(!renderer_->initOpenGL(videodriver->GetLoaderFunction()))
         return false;
+        
     LOG.write(_("OpenGL %1%.%2% supported\n")) % GLVersion.major % GLVersion.minor;
     if(GLVersion.major < RTTR_OGL_MAJOR || (GLVersion.major == RTTR_OGL_MAJOR && GLVersion.minor < RTTR_OGL_MINOR))
     {
@@ -375,6 +508,7 @@
           % ((RTTR_OGL_ES) ? "ES" : "") % RTTR_OGL_MAJOR % RTTR_OGL_MINOR;
         return false;
     }
+    #endif
 
 // auf VSync-Extension testen
 #ifdef _WIN32
@@ -383,6 +517,9 @@
     wglSwapIntervalEXT = reinterpret_cast<SwapIntervalExt_t*>(loadExtension("glXSwapIntervalSGI"));
 #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions returning true"); //ANDROID
+    #endif
     return true;
 }
 
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/network/GameClient.cpp s25client_patched/libs/s25main/network/GameClient.cpp
--- s25client/libs/s25main/network/GameClient.cpp	2024-09-09 22:27:18.977440000 +0200
+++ s25client_patched/libs/s25main/network/GameClient.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "GameClient.h"
 #include "CreateServerInfo.h"
@@ -149,50 +152,94 @@
  */
 void GameClient::Run()
 {
+    #ifdef ANDROID
+    if(state == ClientState::Stopped) {
+         __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run clientstate is stopped returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ClientState::Stopped)
         return;
+    #endif
 
     SocketSet set;
 
     // erstmal auf Daten überprüfen
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run clear socketset"); //ANDROID
+    #endif
     set.Clear();
 
     // zum set hinzufügen
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run adding mainplayer to socket"); //ANDROID
+    #endif
     set.Add(mainPlayer.socket);
     if(set.Select(0, 0) > 0)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run mainplayer empfangen?"); //ANDROID
+        #endif
         // nachricht empfangen
         if(!mainPlayer.receiveMsgs())
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR GameClient::Run receiving message from server failed"); //ANDROID
+            #endif
             LOG.write("Receiving Message from server failed\n");
             ServerLost();
         }
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run suche nach fehlern"); //ANDROID
+    #endif
     // nun auf Fehler prüfen
     set.Clear();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run player zum socket hizufügen(wieder)"); //ANDROID
+    #endif
     // zum set hinzufügen
     set.Add(mainPlayer.socket);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run suche nach fehlern(2)"); //ANDROID
+    #endif
     // auf fehler prüfen
     if(set.Select(0, 2) > 0)
     {
         if(set.InSet(mainPlayer.socket))
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run Server weg(lost)"); //ANDROID
+            #endif
             // Server ist weg
             LOG.write("Error on socket to server\n");
             ServerLost();
         }
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run ist cflient loaded?"); //ANDROID
+    #endif
     if(state == ClientState::Loaded)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run yes"); //ANDROID
+        #endif
         // All players ready?
         if(nwfInfo->isReady())
             OnGameStart();
+    #ifdef ANDROID
+    } else if(state == ClientState::Game){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run executing game frame"); //ANDROID
+        ExecuteGameFrame();
+    }
+    #else
     } else if(state == ClientState::Game)
         ExecuteGameFrame();
+    #endif
 
     // maximal 10 Pakete verschicken
     mainPlayer.sendMsgs(10);
@@ -205,8 +252,16 @@
  */
 void GameClient::Stop()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Stop"); //ANDROID
+    if(state == ClientState::Stopped) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Stop client stopped. returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ClientState::Stopped)
         return;
+    #endif
 
     if(game)
         ExitGame();
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/network/GameServer.cpp s25client_patched/libs/s25main/network/GameServer.cpp
--- s25client/libs/s25main/network/GameServer.cpp	2024-09-09 22:27:18.977440000 +0200
+++ s25client_patched/libs/s25main/network/GameServer.cpp	2024-09-14 18:03:28.605406000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "GameServer.h"
 #include "Debug.h"
@@ -277,8 +280,15 @@
 // Hauptschleife
 void GameServer::Run()
 {
+    #ifdef ANDROID
+    if(state == ServerState::Stopped) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run serverstate is stopped returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ServerState::Stopped)
         return;
+    #endif
 
     // auf tote Clients prüfen
     ClientWatchDog();
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Window.cpp s25client_patched/libs/s25main/Window.cpp
--- s25client/libs/s25main/Window.cpp	2024-09-09 22:27:18.949439000 +0200
+++ s25client_patched/libs/s25main/Window.cpp	2024-09-14 18:03:28.609406000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "Window.h"
 #include "CollisionDetection.h"
@@ -35,8 +38,16 @@
  */
 void Window::Draw()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::draw() is visible?"); //ANDROID
+    if(visible_) {
+         __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::draw() yes drawing window draw_"); //ANDROID
+        Draw_();
+    }
+    #else
     if(visible_)
         Draw_();
+    #endif
 }
 
 DrawPoint Window::GetPos() const
@@ -513,8 +524,16 @@
 
 void Window::Draw_()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::Draw_"); //ANDROID
+    for(Window* control : childIdToWnd_ | boost::adaptors::map_values) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::Draw_ control->Draw()"); //ANDROID
+        control->Draw();
+    }
+    #else
     for(Window* control : childIdToWnd_ | boost::adaptors::map_values)
         control->Draw();
+    #endif
 }
 
 void Window::Msg_ScreenResize(const ScreenResizeEvent& sr)
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/WindowManager.cpp s25client_patched/libs/s25main/WindowManager.cpp
--- s25client/libs/s25main/WindowManager.cpp	2024-09-09 22:27:18.949439000 +0200
+++ s25client_patched/libs/s25main/WindowManager.cpp	2024-09-14 18:03:28.609406000 +0200
@@ -1,6 +1,11 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#include <sstream>
+#include <string>
+#endif
 
 #include "WindowManager.h"
 #include "CollisionDetection.h"
@@ -64,19 +69,60 @@
  */
 void WindowManager::Draw()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw"); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
     // ist ein neuer Desktop eingetragen? Wenn ja, wechseln
-    if(nextdesktop)
+    if(nextdesktop){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw switching desktop"); //ANDROID
         DoDesktopSwitch();
+    }
+    #else
+    if(nextdesktop)
+    DoDesktopSwitch();
+    #endif
+
+    #ifdef ANDROID
+    std::ostringstream oss;
+    oss << curDesktop.get();
+    std::string pointerStr = oss.str();
+    
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw curdesktop: %s", pointerStr.c_str()); //ANDROID
+    #endif
 
+    #ifdef ANDROID
+    if(!curDesktop) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw not desktop return"); //ANDROID
+        return;
+    }
+    #else
     if(!curDesktop)
         return;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw msg paintBefore() to desktop"); //ANDROID
+    #endif
     curDesktop->Msg_PaintBefore();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw desktop draw"); //ANDROID  ABSTURZ HIER!!!!!!!!!!!! fixed
+    #endif
     curDesktop->Draw();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw msg painAfter() to desktop"); //ANDROID
+    #endif
     curDesktop->Msg_PaintAfter();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw close marked windows"); //ANDROID
+    #endif
     // First close all marked windows
     CloseMarkedIngameWnds();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw done closing marked windows"); //ANDROID
+    #endif
     for(auto& wnd : windows)
     {
         // If the window is not minimized, call paintAfter
@@ -88,8 +134,14 @@
             wnd->Msg_PaintAfter();
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw drawtooltip"); //ANDROID
     DrawToolTip();
+    #endif
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw drawcursor"); //ANDROID
     DrawCursor();
+    #endif
 }
 
 /**
@@ -100,8 +152,18 @@
  */
 bool WindowManager::IsDesktopActive()
 {
+    #ifdef ANDROID
+    if(curDesktop){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "INFO WindowManager::IsDesktopActive() desktop is active"); //ANDROID
+        return curDesktop->IsActive();
+    }
+    #else
     if(curDesktop)
         return curDesktop->IsActive();
+    #endif
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR WindowManager::Draw desktop not active"); //ANDROID
+    #endif
 
     return false;
 }
@@ -713,28 +775,67 @@
  */
 void WindowManager::DoDesktopSwitch()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch()"); //ANDROID
+    #endif
     RTTR_Assert(nextdesktop);
     VIDEODRIVER.ClearScreen();
 
     SetToolTip(nullptr, "");
 
     // If we have a current desktop close all windows
+    #ifdef ANDROID
+    if(curDesktop){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() closing all windows cause of current desktop"); //ANDROID
+        windows.clear();
+    }
+    #else
     if(curDesktop)
         windows.clear();
+    #endif
 
     // Do the switch
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() do the desktop switch. move nextdesktop"); //ANDROID
+    #endif
     curDesktop = std::move(nextdesktop);
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() desktop -> set active(true)"); //ANDROID
+    #endif
     curDesktop->SetActive(true);
 
+    #ifdef ANDROID
+    for(auto& nextWnd : nextWnds){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() show next window"); //ANDROID
+        Show(std::move(nextWnd));
+    }
+    #else
     for(auto& nextWnd : nextWnds)
         Show(std::move(nextWnd));
+    #endif
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() clear next window"); //ANDROID
+    #endif
     nextWnds.clear();
 
+    #ifdef ANDROID
+    if(!VIDEODRIVER.IsLeftDown()) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() enable mouse"); //ANDROID
+        disable_mouse = false;
+    }
+    #else
     if(!VIDEODRIVER.IsLeftDown())
         disable_mouse = false;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() dummy mouse"); //ANDROID
+    #endif
     // Dummy mouse move to init hovering etc
     Msg_MouseMove(MouseCoords(VIDEODRIVER.GetMousePos()));
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() returning"); //ANDROID
+    #endif
 }
 
 void WindowManager::CloseMarkedIngameWnds()
