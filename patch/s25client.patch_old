diff -ruN --binary -x '.*' -x patched s25client/CMakeLists.txt s25client_patched/CMakeLists.txt
--- s25client/CMakeLists.txt	2024-09-29 22:16:56.335718782 +0200
+++ s25client_patched/CMakeLists.txt	2024-10-01 17:42:19.666590000 +0200
@@ -22,9 +22,17 @@
     message(STATUS "Used Toolchain definition file '${CMAKE_TOOLCHAIN_FILE}'")
 endif()
 
-list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules" "${CMAKE_SOURCE_DIR}/external/libutil/cmake")
-if(CMAKE_VERSION VERSION_LESS 3.14)
-    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/external/libutil/cmake/cmake_3.14")
+
+if(ANDROID)
+    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/src/s25client/cmake/Modules" "${CMAKE_SOURCE_DIR}/src/s25client/external/libutil/cmake")
+    if(CMAKE_VERSION VERSION_LESS 3.14)
+        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/src/s25client/external/libutil/cmake/cmake_3.14")
+    endif()
+else()
+    list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/Modules" "${CMAKE_SOURCE_DIR}/external/libutil/cmake")
+    if(CMAKE_VERSION VERSION_LESS 3.14)
+        list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/external/libutil/cmake/cmake_3.14")
+    endif()
 endif()
 
 include(EnableCCache)
@@ -274,6 +282,10 @@
     else()
         message(FATAL_ERROR "Unknown architecture for sizeof(void*)=${CMAKE_SIZEOF_VOID_P}")
     endif()
+elseif(ANDROID)
+    message(STATUS "Unofficial build with processor arch: ${CMAKE_SYSTEM_PROCESSOR}. Skipping release scripts and updater.")
+    unset(PLATFORM_ARCH)
+    set(RTTR_BUILD_UPDATER OFF CACHE INTERNAL "Disabled")
 else()
     if(${CMAKE_SYSTEM_PROCESSOR} MATCHES "i.86")
         set(PLATFORM_ARCH "i386")
@@ -300,7 +312,12 @@
     set(BOOST_ROOT ${rttrContribBoostDir} CACHE PATH "Path to find boost at")
 endif()
 
-set(BoostPackages filesystem iostreams locale program_options)
+if(ANDROID)
+    set(BoostPackages filesystem iostreams locale system thread program_options)
+else()
+    set(BoostPackages filesystem iostreams locale program_options)
+endif()
+
 if(BUILD_TESTING)
     # Avoid having to search for this in all tests speeding up configure
     list(APPEND BoostPackages unit_test_framework)
diff -ruN --binary -x '.*' -x patched s25client/external/CMakeLists.txt s25client_patched/external/CMakeLists.txt
--- s25client/external/CMakeLists.txt	2024-09-29 22:16:56.623725774 +0200
+++ s25client_patched/external/CMakeLists.txt	2024-09-29 22:25:02.399153000 +0200
@@ -39,7 +39,11 @@
 add_subdirectory(libsiedler2)
 add_subdirectory(libutil)
 add_subdirectory(mygettext)
-add_subdirectory(s25edit)
+
+if(!ANDROID)
+    add_subdirectory(s25edit)
+endif()
+
 if(RTTR_BUILD_UPDATER)
     add_subdirectory(s25update)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/external/liblobby/CMakeLists.txt s25client_patched/external/liblobby/CMakeLists.txt
--- s25client/external/liblobby/CMakeLists.txt	2024-09-29 22:17:14.284154394 +0200
+++ s25client_patched/external/liblobby/CMakeLists.txt	2024-09-29 22:25:02.399153000 +0200
@@ -20,7 +20,13 @@
 
 add_library(lobby STATIC EXCLUDE_FROM_ALL ${SOURCES_LOBBY})
 target_include_directories(lobby PUBLIC include)
-target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext)
+
+if(ANDROID)
+    target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext log)
+else()
+    target_link_libraries(lobby PUBLIC s25util::common s25util::log s25util::network PRIVATE mygettext)
+endif()
+
 target_compile_features(lobby PUBLIC cxx_std_17)
 set_target_properties(lobby PROPERTIES CXX_EXTENSIONS OFF)
 
diff -ruN --binary -x '.*' -x patched s25client/external/liblobby/src/LobbyClient.cpp s25client_patched/external/liblobby/src/LobbyClient.cpp
--- s25client/external/liblobby/src/LobbyClient.cpp	2024-09-29 22:17:14.284154394 +0200
+++ s25client_patched/external/liblobby/src/LobbyClient.cpp	2024-09-29 22:25:02.399153000 +0200
@@ -3,6 +3,9 @@
 //
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "liblobby/LobbyClient.h"
 #include "liblobby/LobbyInterface.h"
@@ -26,6 +29,9 @@
 
 LobbyClient::~LobbyClient()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::~LobbyClient() trennen von verbindung zum server"); //ANDROID
+    #endif
     Stop();
 }
 
@@ -45,12 +51,25 @@
  */
 void LobbyClient::Run()
 {
-    if(state == CS_STOPPED)
+    #ifdef ANDROID
+    if(state == CS_STOPPED) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run() lobbyclient state is stopped returning"); //ANDROID
         return;
+    }
+    #else
+    if(state == CS_STOPPED)
+    return;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run()"); //ANDROID
+    #endif
     // nachrichten empfangen
     if(recv_queue.recvAll(socket) < 0)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "LobbyClient::Run()"); //ANDROID
+        #endif
         LOG.write("Receiving Message from server failed\n");
         ServerLost();
         return;
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/cmake/cmake_3.14/FindBoost.cmake s25client_patched/external/libutil/cmake/cmake_3.14/FindBoost.cmake
--- s25client/external/libutil/cmake/cmake_3.14/FindBoost.cmake	2024-09-29 22:17:14.376156627 +0200
+++ s25client_patched/external/libutil/cmake/cmake_3.14/FindBoost.cmake	2024-09-29 22:25:02.399153000 +0200
@@ -283,6 +283,7 @@
 endif()
 
 
+
 #-------------------------------------------------------------------------------
 #  FindBoost functions & macros
 #
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/cmake/FindMiniupnpc.cmake s25client_patched/external/libutil/cmake/FindMiniupnpc.cmake
--- s25client/external/libutil/cmake/FindMiniupnpc.cmake	2024-09-29 22:17:14.376156627 +0200
+++ s25client_patched/external/libutil/cmake/FindMiniupnpc.cmake	2024-09-29 22:25:02.399153000 +0200
@@ -9,6 +9,7 @@
 #  MINIUPNPC_LIBRARY     - Library to link to libminiupnpc.
 #  MINIUPNPC_FOUND       - True if libminiupnpc found.
 
+
 FIND_PATH(MINIUPNPC_INCLUDE_DIR NAMES miniupnpc/miniupnpc.h PATHS
 	${MINIUPNPC_DIR_SEARCH}/miniupnpc/include
 	/usr/include
@@ -21,6 +22,7 @@
 	/usr/local/lib
 )
 
+
 INCLUDE(FindPackageHandleStandardArgs)
 FIND_PACKAGE_HANDLE_STANDARD_ARGS(Miniupnpc DEFAULT_MSG MINIUPNPC_INCLUDE_DIR MINIUPNPC_LIBRARY)
 
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/libs/common/CMakeLists.txt s25client_patched/external/libutil/libs/common/CMakeLists.txt
--- s25client/external/libutil/libs/common/CMakeLists.txt	2024-09-29 22:17:14.380156724 +0200
+++ s25client_patched/external/libutil/libs/common/CMakeLists.txt	2024-09-29 22:25:02.403153000 +0200
@@ -2,6 +2,10 @@
 #
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+if(ANDROID)
+    find_library(SDL2 SDL2) #ANDROID
+endif()
+
 set(_BoostComponents filesystem)
 if(WIN32)
     # Locale only on windows
@@ -19,7 +23,13 @@
 add_library(s25util::common ALIAS s25util_common)
 
 target_include_directories(s25util_common PUBLIC include PRIVATE include/s25util)
-target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem)
+
+if(ANDROID)
+    target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem SDL2)
+else()
+    target_link_libraries(s25util_common PUBLIC endian::static Boost::nowide Boost::filesystem)
+endif()
+
 target_compile_features(s25util_common PUBLIC cxx_std_17)
 # PIC Required for linking into shared libs
 set_target_properties(s25util_common PROPERTIES CXX_EXTENSIONS OFF POSITION_INDEPENDENT_CODE ON)
diff -ruN --binary -x '.*' -x patched s25client/external/libutil/libs/common/src/System_Other.cpp s25client_patched/external/libutil/libs/common/src/System_Other.cpp
--- s25client/external/libutil/libs/common/src/System_Other.cpp	2024-09-29 22:17:14.380156724 +0200
+++ s25client_patched/external/libutil/libs/common/src/System_Other.cpp	2024-09-29 22:25:02.403153000 +0200
@@ -2,9 +2,14 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
 #include "System.h"
 #include <stdexcept>
 
+
 boost::filesystem::path System::getHomePath()
 {
     boost::filesystem::path homePath = getPathFromEnvVar("HOME");
@@ -17,9 +22,14 @@
     return homePath;
 }
 
+
 std::string System::getUserName()
 {
+    #ifdef ANDROID
+    std::string name = "android";
+    #else
     std::string name = getEnvVar("USER");
+    #endif
     if(name.empty())
         throw std::runtime_error("Could not get username");
     return name;
diff -ruN --binary -x '.*' -x patched s25client/extras/ai-battle/CMakeLists.txt s25client_patched/extras/ai-battle/CMakeLists.txt
--- s25client/extras/ai-battle/CMakeLists.txt	2024-09-29 22:16:56.627725872 +0200
+++ s25client_patched/extras/ai-battle/CMakeLists.txt	2024-09-29 22:25:02.403153000 +0200
@@ -2,7 +2,12 @@
 #
 # SPDX-License-Identifier: GPL-2.0-or-later
 
+if(ANDROID)
+add_library(ai-battle main.cpp HeadlessGame.cpp)
+else()
 add_executable(ai-battle main.cpp HeadlessGame.cpp)
+endif()
+
 target_link_libraries(ai-battle PRIVATE s25Main Boost::program_options Boost::nowide)
 
 if(WIN32)
diff -ruN --binary -x '.*' -x patched s25client/extras/audioDrivers/SDL/CMakeLists.txt s25client_patched/extras/audioDrivers/SDL/CMakeLists.txt
--- s25client/extras/audioDrivers/SDL/CMakeLists.txt	2024-09-29 22:16:56.627725872 +0200
+++ s25client_patched/extras/audioDrivers/SDL/CMakeLists.txt	2024-09-29 22:25:02.403153000 +0200
@@ -20,9 +20,11 @@
     target_link_libraries(audioSDL PRIVATE audiodrv SDL_mixer::SDL_mixer)
     enable_warnings(audioSDL)
 
-    install(TARGETS audioSDL
-      RUNTIME DESTINATION ${RTTR_DRIVERDIR}/audio
-      LIBRARY DESTINATION ${RTTR_DRIVERDIR}/audio
-    )
+    if(!ANDROID)
+        install(TARGETS audioSDL
+          RUNTIME DESTINATION ${RTTR_DRIVERDIR}/audio
+          LIBRARY DESTINATION ${RTTR_DRIVERDIR}/audio
+        )
+    endif()
     add_dependencies(drivers audioSDL)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/CMakeLists.txt s25client_patched/extras/videoDrivers/SDL2/CMakeLists.txt
--- s25client/extras/videoDrivers/SDL2/CMakeLists.txt	2024-09-29 22:16:56.627725872 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/CMakeLists.txt	2024-09-29 22:25:02.403153000 +0200
@@ -7,7 +7,13 @@
 
 if(SDL2_FOUND)
     add_library(videoSDL2 SHARED ${RTTR_DRIVER_INTERFACE} VideoSDL2.cpp VideoSDL2.h icon.h icon.cpp)
-    target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2)
+    
+    if(ANDROID)
+        target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2 log GL)
+    else()
+        target_link_libraries(videoSDL2 PRIVATE videodrv s25util::common glad Boost::nowide SDL2::SDL2)
+    endif()
+    
     enable_warnings(videoSDL2)
 
     if(WIN32)
@@ -15,9 +21,11 @@
         gather_dll_by_name(SDL2 SDL2.dll)
     endif()
 
-    install(TARGETS videoSDL2
-      RUNTIME DESTINATION ${RTTR_DRIVERDIR}/video
-      LIBRARY DESTINATION ${RTTR_DRIVERDIR}/video
-    )
+    if (!ANDROID)
+        install(TARGETS videoSDL2
+          RUNTIME DESTINATION ${RTTR_DRIVERDIR}/video
+          LIBRARY DESTINATION ${RTTR_DRIVERDIR}/video
+        )
+    endif()
     add_dependencies(drivers videoSDL2)
 endif()
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/VideoSDL2.cpp s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.cpp
--- s25client/extras/videoDrivers/SDL2/VideoSDL2.cpp	2024-09-29 22:16:56.627725872 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.cpp	2024-10-03 13:14:39.014589000 +0200
@@ -2,6 +2,11 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#include <gl4esinit.h>
+#endif
+
 #include "VideoSDL2.h"
 #include "driver/Interface.h"
 #include "driver/VideoDriverLoaderInterface.h"
@@ -109,6 +114,9 @@
 
 bool VideoSDL2::CreateScreen(const std::string& title, const VideoMode& size, bool fullscreen)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoSDL2::CreateScreen initialized? %d", initialized); //ANDROID
+    #endif
     if(!initialized)
         return false;
 
@@ -117,11 +125,16 @@
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, RTTR_OGL_MINOR));
     SDL_GLprofile profile;
     if((RTTR_OGL_ES))
-        profile = SDL_GL_CONTEXT_PROFILE_ES;
+	profile = SDL_GL_CONTEXT_PROFILE_ES;
     else if((RTTR_OGL_COMPAT))
         profile = SDL_GL_CONTEXT_PROFILE_COMPATIBILITY;
     else
         profile = SDL_GL_CONTEXT_PROFILE_CORE;
+
+    #ifdef ANDROID
+    profile = SDL_GL_CONTEXT_PROFILE_ES;
+    #endif
+    
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, profile));
 
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8));
@@ -129,7 +142,11 @@
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8));
     CHECK_SDL(SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1));
 
+    #ifdef ANDROID
+    int wndPos = SDL_WINDOWPOS_UNDEFINED;
+    #else
     int wndPos = SDL_WINDOWPOS_CENTERED;
+    #endif
 
     const auto requestedSize = fullscreen ? FindClosestVideoMode(size) : size;
     unsigned commonFlags = SDL_WINDOW_OPENGL;
@@ -166,7 +183,7 @@
     {
         SDL_SetWindowIcon(window, iconSurf);
         SDL_FreeSurface(iconSurf);
-    } else
+    } else 
         PrintError(SDL_GetError());
 
     context = SDL_GL_CreateContext(window);
@@ -268,6 +285,17 @@
 
 bool VideoSDL2::MessageLoop()
 {
+    int windowW, windowH;
+    SDL_GetWindowSize(window, &windowW, &windowH);
+    
+    #ifdef ANDROID
+    /*float finger1x = 0;
+    float finger1y = 0;
+    float finger2x = 0;
+    float finger2y = 0;*/
+    SDL_TouchID touchDevice = SDL_GetTouchDevice(1);
+    #endif
+    
     SDL_Event ev;
     while(SDL_PollEvent(&ev))
     {
@@ -405,6 +433,61 @@
                 mouse_xy.pos = getGuiScale().screenToView(Position(ev.motion.x, ev.motion.y));
                 CallBack->Msg_MouseMove(mouse_xy);
                 break;
+            #ifdef ANDROID
+            case SDL_FINGERDOWN:
+                ev.tfinger.x = ev.tfinger.x * windowW;
+                ev.tfinger.y = ev.tfinger.y * windowH;
+                
+                mouse_xy.pos = getGuiScale().screenToView(Position((int)ev.tfinger.x, (int)ev.tfinger.y));
+                mouse_xy.ldown = true;
+                CallBack->Msg_LeftDown(mouse_xy);
+                break;
+            case SDL_FINGERUP:
+                if(!SDL_GetNumTouchFingers(touchDevice))
+                    isMultigesture = false;
+                
+                ev.tfinger.x = ev.tfinger.x * windowW;
+                ev.tfinger.y = ev.tfinger.y * windowH;
+                
+                mouse_xy.pos = getGuiScale().screenToView(Position((int)ev.tfinger.x, (int)ev.tfinger.y));
+                mouse_xy.ldown = false;
+                CallBack->Msg_LeftUp(mouse_xy);
+                break;
+            case SDL_MULTIGESTURE:
+            {
+                isMultigesture = true;
+                if( fabs( ev.mgesture.dDist ) > 0.001 ) {
+                    if( ev.mgesture.dDist > 0 ) {
+                        CallBack->Msg_WheelUp(mouse_xy);
+                    } else {
+                        CallBack->Msg_WheelDown(mouse_xy);
+                    }
+                }
+            }
+                break;
+            case SDL_FINGERMOTION:
+                if (isMultigesture || SDL_GetNumTouchFingers(touchDevice) > 1) {
+                    break;
+                    
+                    /*SDL_Finger* finger1 = SDL_GetTouchFinger(touchDevice, 0);
+                    finger1x = finger1->x;
+                    finger1y = finger1->y;
+                    
+                    SDL_Finger* finger2 = SDL_GetTouchFinger(touchDevice, 1);
+                    finger2x = finger2->x;
+                    finger2y = finger2->y;
+                    
+                    ev.tfinger.x = (finger1x + finger2x) / 2.0f * windowW;
+                    ev.tfinger.y = (finger1y + finger2y) / 2.0f * windowH;*/
+                } else {
+                    ev.tfinger.x = ev.tfinger.x * windowW;
+                    ev.tfinger.y = ev.tfinger.y * windowH;
+                }
+                
+                mouse_xy.pos = getGuiScale().screenToView(Position((int)ev.tfinger.x, (int)ev.tfinger.y));
+                CallBack->Msg_MouseMove(mouse_xy);
+                break;
+            #endif
         }
     }
 
@@ -437,7 +520,11 @@
 
 OpenGL_Loader_Proc VideoSDL2::GetLoaderFunction() const
 {
+    #ifdef ANDROID
+    return gl4es_GetProcAddress;
+    #else
     return SDL_GL_GetProcAddress;
+    #endif
 }
 
 void VideoSDL2::SetMousePos(Position pos)
diff -ruN --binary -x '.*' -x patched s25client/extras/videoDrivers/SDL2/VideoSDL2.h s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.h
--- s25client/extras/videoDrivers/SDL2/VideoSDL2.h	2024-09-29 22:16:56.627725872 +0200
+++ s25client_patched/extras/videoDrivers/SDL2/VideoSDL2.h	2024-10-03 13:08:01.184298000 +0200
@@ -58,6 +58,9 @@
     void HandlePaste();
     void UpdateCurrentSizes();
     void MoveWindowToCenter();
+    #ifdef ANDROID
+    bool isMultigesture;
+    #endif
 
     SDL_Window* window;
     SDL_GLContext context;
diff -ruN --binary -x '.*' -x patched s25client/libs/rttrConfig/CMakeLists.txt s25client_patched/libs/rttrConfig/CMakeLists.txt
--- s25client/libs/rttrConfig/CMakeLists.txt	2024-09-29 22:16:56.631725968 +0200
+++ s25client_patched/libs/rttrConfig/CMakeLists.txt	2024-09-29 22:25:02.403153000 +0200
@@ -10,10 +10,19 @@
   src/RttrConfig.h
 )
 target_include_directories(rttrConfig INTERFACE src)
-target_link_libraries(rttrConfig
-    PUBLIC s25util::common Boost::filesystem
-    PRIVATE s25Common
-)
+
+if(ANDROID)
+    target_link_libraries(rttrConfig
+        PUBLIC s25util::common Boost::filesystem log
+        PRIVATE s25Common
+    )
+else()
+    target_link_libraries(rttrConfig
+        PUBLIC s25util::common Boost::filesystem
+        PRIVATE s25Common
+    )
+endif()
+
 set_property(TARGET rttrConfig PROPERTY POSITION_INDEPENDENT_CODE ON)
 
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/build_paths.h.cmake build_paths.h @ONLY)
diff -ruN --binary -x '.*' -x patched s25client/libs/rttrConfig/src/RttrConfig.cpp s25client_patched/libs/rttrConfig/src/RttrConfig.cpp
--- s25client/libs/rttrConfig/src/RttrConfig.cpp	2024-09-29 22:16:56.631725968 +0200
+++ s25client_patched/libs/rttrConfig/src/RttrConfig.cpp	2024-09-29 22:25:02.403153000 +0200
@@ -2,6 +2,10 @@
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#ifdef ANDROID
+#include <android/log.h>
+#endif
+
 #include "RttrConfig.h"
 #include "RTTR_Assert.h"
 #include "s25util/Log.h"
@@ -33,9 +37,15 @@
 
 bfs::path RttrConfig::GetPrefixPath()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::getPrefixPath() need to get prefix path"); //ANDROID
+    #endif
     // Determine install prefix
     // Get path to current executable (at least for checks)
     bfs::path fullExeFilepath = System::getExecutablePath();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::getPrefixPath() executablePath %s", fullExeFilepath.c_str()); //ANDROID
+    #endif
     // This should always work unless we have some missing implementation or a bad error
     if(fullExeFilepath.empty())
     {
@@ -89,22 +99,59 @@
 
 boost::filesystem::path RttrConfig::ExpandPath(const std::string& path) const
 {
-    if(path.empty())
+    #ifdef ANDROID
+    if(path.empty()) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  path is empty using prefixPath"); //ANDROID
+        return prefixPath_;
+    }
+    #else
+        if(path.empty())
         return prefixPath_;
+    #endif
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  expanding path: %s", path.c_str()); //ANDROID
+    #endif
+    
     bfs::path outPath;
     if(path[0] == '<')
     {
         static const char rttrPathId[] = "<RTTR_";
         size_t startPos = path.find(rttrPathId);
+
+        #ifdef ANDROID
+        if(startPos > 0u) {
+            throw std::runtime_error("<RTTR_X> placeholders only allowed at start of path");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  <RTTR_X> placeholders only allowed at start of path"); //ANDROID
+        }
+        #else
         if(startPos > 0u)
             throw std::runtime_error("<RTTR_X> placeholders only allowed at start of path");
+        #endif
+
         size_t endPos = path.find('>');
-        if(endPos == std::string::npos)
+        #ifdef ANDROID
+        if(endPos == std::string::npos) {
             throw std::runtime_error("Incomplete <RTTR_X> placeholder found!");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  Incomplete <RTTR_X> placeholder found!"); //ANDROID
+        }
+        #else
+        if(endPos == std::string::npos)
+        throw std::runtime_error("Incomplete <RTTR_X> placeholder found!");
+        #endif
+
         std::string entry = path.substr(sizeof(rttrPathId) - 1, endPos - startPos - sizeof(rttrPathId) + 1);
         auto it = pathMappings.find(entry);
-        if(it == pathMappings.end())
+        #ifdef ANDROID
+        if(it == pathMappings.end()) {
             throw std::runtime_error("Invalid <RTTR_X> placeholder found!");
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath  Invalid <RTTR_X> placeholder found!"); //ANDROID
+        }
+        #else
+        if(it == pathMappings.end())
+        throw std::runtime_error("Invalid <RTTR_X> placeholder found!");
+        #endif
+
         outPath = bfs::path(it->second) / path.substr(endPos + 1);
     } else
         outPath = path;
@@ -112,6 +159,9 @@
         outPath = homePath / outPath.string().substr(2);
 
     outPath = bfs::absolute(outPath, prefixPath_).lexically_normal();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttrConfig::ExpandPath returning path: %s", outPath.c_str()); //ANDROID
+    #endif
     return outPath.make_preferred();
 }
 
@@ -123,7 +173,11 @@
 
 bool RttrConfig::Init()
 {
+    #ifdef ANDROID
+    prefixPath_ = System::getHomePath();
+    #else
     prefixPath_ = GetPrefixPath();
+    #endif
     if(prefixPath_.empty())
         return false;
     // Make the prefix path our working directory as all other paths are relative to that
diff -ruN --binary -x '.*' -x patched s25client/libs/s25client/CMakeLists.txt s25client_patched/libs/s25client/CMakeLists.txt
--- s25client/libs/s25client/CMakeLists.txt	2024-09-29 22:16:56.631725968 +0200
+++ s25client_patched/libs/s25client/CMakeLists.txt	2024-09-29 22:25:02.403153000 +0200
@@ -18,9 +18,16 @@
     set(s25client_RC )
 endif()
 
-add_executable(s25client s25client.cpp commands.cpp ${s25client_RC})
-target_link_libraries(s25client PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld)
-add_dependencies(s25client drivers)
+if(ANDROID)
+    add_library(main SHARED s25client.cpp commands.cpp ${s25client_RC})
+    target_link_libraries(main PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld log)
+    add_dependencies(main drivers)
+else()
+    add_executable(s25client s25client.cpp commands.cpp ${s25client_RC})
+    target_link_libraries(s25client PRIVATE s25Main Boost::program_options Boost::nowide rttr::vld)
+    add_dependencies(s25client drivers)
+endif()
+
 
 if(WIN32)
     target_include_directories(s25client PRIVATE ${rcDir})
@@ -46,4 +53,6 @@
     gather_dll_copy(s25client)
 endif()
 
-INSTALL(TARGETS s25client RUNTIME DESTINATION ${RTTR_BINDIR})
+if(NOT ANDROID)
+    INSTALL(TARGETS s25client RUNTIME DESTINATION ${RTTR_BINDIR})
+endif()
diff -ruN --binary -x '.*' -x patched s25client/libs/s25client/s25client.cpp s25client_patched/libs/s25client/s25client.cpp
--- s25client/libs/s25client/s25client.cpp	2024-09-29 22:16:56.631725968 +0200
+++ s25client_patched/libs/s25client/s25client.cpp	2024-10-01 20:23:51.373508000 +0200
@@ -1,6 +1,10 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <SDL.h>
+#include <android/log.h>
+#endif
 
 #include "Debug.h"
 #include "GameManager.h"
@@ -85,6 +89,9 @@
     if(waited)
         return;
     waited = true;
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Press ENTER to close this window . . ."); //ANDROID
+    #endif
     bnw::cout << "\n\nPress ENTER to close this window . . ." << std::endl;
     bnw::cin.clear();
     bnw::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
@@ -142,6 +149,9 @@
 
 void showCrashMessage()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RttR crashed. Please restart the application!"); //ANDROID
+    #endif
     std::string text = gettext_noop("RttR crashed. Please restart the application!");
     std::string errorTxt = gettext_noop("Error");
     try
@@ -363,6 +373,9 @@
 
 bool InitDirectories()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() funktion"); //ANDROID
+    #endif
     // Note: Do not use logger yet. Filepath may not exist
     const auto curPath = bfs::current_path();
     LOG.write("Starting in %1%\n", LogTarget::Stdout) % curPath;
@@ -370,14 +383,30 @@
     if(!MigrateFilesAndDirectories())
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Creating all folders"); //ANDROID
+    #endif
     // Create all required/useful folders
     const std::array<std::string, 10> dirs = {
       {s25::folders::config, s25::folders::logs, s25::folders::mapsOwn, s25::folders::mapsPlayed, s25::folders::replays,
        s25::folders::save, s25::folders::assetsUserOverrides, s25::folders::screenshots, s25::folders::playlists}};
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() done creating folders"); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() s25::folders::config %s", s25::folders::config  ); //ANDROID
+    #endif
 
     for(const std::string& rawDir : dirs)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() %s", rawDir.c_str()); //ANDROID
+        #endif
         const bfs::path dir = RTTRCONFIG.ExpandPath(rawDir);
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() %s", dir.c_str()); //ANDROID
+        #endif
         boost::system::error_code ec;
         bfs::create_directories(dir, ec);
         if(ec != boost::system::errc::success)
@@ -386,6 +415,9 @@
             // Make sure we catch that
             try
             {
+                #ifdef ANDROID
+                __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() folders could not be created"); //ANDROID
+                #endif
                 s25util::error(std::string("Directory ") + dir.string() + " could not be created.");
                 s25util::error("Failed to start the game");
             } catch(const std::runtime_error& error)
@@ -395,10 +427,16 @@
             return false;
         }
     }
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Writing log: Directory for user data (config etc.):"); //ANDROID
+    #endif
     LOG.write("Directory for user data (config etc.): %1%\n", LogTarget::Stdout)
       % RTTRCONFIG.ExpandPath(s25::folders::config);
 
     // Write this to file too, after folders are created
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() set log filepath"); //ANDROID
+    #endif
     LOG.setLogFilepath(RTTRCONFIG.ExpandPath(s25::folders::logs));
     try
     {
@@ -407,15 +445,24 @@
         LOG.write("Starting in %1%\n", LogTarget::File) % curPath;
     } catch(const std::exception& e)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Error initializing log: \n" ); //ANDROID
+        #endif
         LOG.write("Error initializing log: %1%\nSystem reports: %2%\n", LogTarget::Stderr) % e.what()
           % LOG.getLastError();
         return false;
     }
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitDirectories() Returning TRUE"); //ANDROID
+    #endif
     return true;
 }
 
 bool InitGame(GameManager& gameManager)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "InitGame Funktion"); //ANDROID
+    #endif
     libsiedler2::setAllocator(new GlAllocator());
 
     // Socketzeug initialisieren
@@ -425,10 +472,16 @@
         s25util::error("Failed to start the game");
         return false;
     }
-
+    
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "SPIEL STARTEN!!"); //ANDROID
+    #endif
     // Spiel starten
     if(!gameManager.Start())
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Failed to start the game"); //ANDROID
+        #endif
         s25util::error("Failed to start the game");
         return false;
     }
@@ -450,6 +503,9 @@
         return 1;
 
     // Zufallsgenerator initialisieren (Achtung: nur für Animations-Offsets interessant, für alles andere
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Directories created successfully!"); //ANDROID
+    #endif
     // (spielentscheidende) wird unser Generator verwendet)
     srand(static_cast<unsigned>(std::time(nullptr)));
 
@@ -457,10 +513,16 @@
     {
         try
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Convert sounds"); //ANDROID
+            #endif
             convertAndSaveSounds(RTTRCONFIG, RTTRCONFIG.ExpandPath("<RTTR_USERDATA>/convertedSoundeffects"));
             return 0;
         } catch(const std::runtime_error& e)
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Error: %s", e.what()); //ANDROID
+            #endif
             bnw::cerr << "Error: " << e.what() << "\n";
             return 1;
         }
@@ -470,6 +532,9 @@
                                                       WINDOWMANAGER);
     try
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() running initgame(gamemanager)"); //ANDROID
+        #endif
         if(!InitGame(gameManager))
             return 2;
 
@@ -484,6 +549,10 @@
         }
 
         // Hauptschleife
+        
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Hauptschleife..."); //ANDROID
+        #endif
 
         while(gameManager.Run())
         {
@@ -492,6 +561,10 @@
 #endif // !_WIN32
         }
 
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "RunProgram() Killing game"); //ANDROID
+        #endif
+
         // Spiel beenden
         gameManager.Stop();
         libsiedler2::setAllocator(nullptr);
@@ -522,6 +595,15 @@
 // NOLINTNEXTLINE(bugprone-exception-escape)
 int main(int argc, char** argv)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Starting Main function, %s", SDL_AndroidGetInternalStoragePath()); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
+    SDL_SetHint(SDL_HINT_TOUCH_MOUSE_EVENTS, "0");  // Converts touch events to mouse events
+    SDL_SetHint(SDL_HINT_MOUSE_TOUCH_EVENTS, "0");  // Converts mouse events to touch events
+    #endif
+
     bnw::args _(argc, argv);
 
     po::options_description desc("Allowed options");
@@ -570,11 +652,17 @@
         result = e.code;
     } catch(const std::exception& e)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "An exception occurred: %s", e.what()); //ANDROID
+        #endif
         bnw::cerr << "An exception occurred: " << e.what() << "\n\n";
         handleException(nullptr);
         result = 1;
     } catch(...)
     {
+               #ifdef ANDROID
+               __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "An unknown exception occurred!"); //ANDROID
+               #endif
         bnw::cerr << "An unknown exception occurred\n";
         handleException(nullptr);
         result = 1;
@@ -582,5 +670,8 @@
     if(result)
         WaitForEnter();
 
+    #ifdef ANDROID
+    exit(result); //to full close android app
+    #endif
     return result;
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/CMakeLists.txt s25client_patched/libs/s25main/CMakeLists.txt
--- s25client/libs/s25main/CMakeLists.txt	2024-09-29 22:16:56.631725968 +0200
+++ s25client_patched/libs/s25main/CMakeLists.txt	2024-09-29 22:25:02.407153000 +0200
@@ -50,20 +50,37 @@
 set_target_properties(s25Main PROPERTIES CXX_EXTENSIONS OFF)
 target_compile_features(s25Main PUBLIC cxx_std_17)
 
-target_link_libraries(s25Main PUBLIC
-    siedler2
-    lobby_c
-    s25util::common
-    s25util::network
-    mygettext
-    s25Common
-    rttrConfig
-    gamedata
-    glad
-    driver
-    Boost::filesystem Boost::disable_autolinking
-    PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::nowide samplerate_cpp
+if(ANDROID)
+    target_link_libraries(s25Main PUBLIC
+        siedler2
+        lobby_c
+        s25util::common
+        s25util::network
+        mygettext
+        s25Common
+        rttrConfig
+        gamedata
+        glad
+        driver
+        Boost::filesystem Boost::disable_autolinking
+        PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::system Boost::thread Boost::nowide samplerate_cpp log iconv
 )
+else()
+    target_link_libraries(s25Main PUBLIC
+        siedler2
+        lobby_c
+        s25util::common
+        s25util::network
+        mygettext
+        s25Common
+        rttrConfig
+        gamedata
+        glad
+        driver
+        Boost::filesystem Boost::disable_autolinking
+        PRIVATE BZip2::BZip2 Boost::iostreams Boost::locale Boost::system Boost::thread Boost::nowide samplerate_cpp
+)
+endif()
 
 if(WIN32)
     include(CheckIncludeFiles)
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Debug.cpp s25client_patched/libs/s25main/Debug.cpp
--- s25client/libs/s25main/Debug.cpp	2024-09-29 22:16:56.631725968 +0200
+++ s25client_patched/libs/s25main/Debug.cpp	2024-09-29 22:25:02.407153000 +0200
@@ -149,8 +149,13 @@
 #else
 void captureBacktrace(std::vector<void*>& stacktrace) noexcept
 {
+    #ifdef ANDROID
+    (void)stacktrace; // stacktrace not available on android...
+    return;
+    #else
     unsigned num_frames = backtrace(&stacktrace[0], stacktrace.size());
     stacktrace.resize(num_frames);
+    #endif
 }
 #endif
 } // namespace
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/desktops/dskGameInterface.cpp s25client_patched/libs/s25main/desktops/dskGameInterface.cpp
--- s25client/libs/s25main/desktops/dskGameInterface.cpp	2024-09-29 22:16:56.647726357 +0200
+++ s25client_patched/libs/s25main/desktops/dskGameInterface.cpp	2024-10-01 20:37:35.005997000 +0200
@@ -98,7 +98,6 @@
     ID_txtNumMsg
 };
 }
-
 dskGameInterface::dskGameInterface(std::shared_ptr<Game> game, std::shared_ptr<const NWFInfo> nwfInfo,
                                    unsigned playerIdx, bool initOGL)
     : Desktop(nullptr), game_(std::move(game)), nwfInfo_(std::move(nwfInfo)),
@@ -209,6 +208,9 @@
 
 void dskGameInterface::StopScrolling()
 {
+    #ifdef ANDROID
+    //mouseMove = false;
+    #endif
     isScrolling = false;
     WINDOWMANAGER.SetCursor(road.mode == RoadBuildMode::Disabled ? Cursor::Hand : Cursor::Remove);
 }
@@ -450,6 +452,267 @@
         iconPos -= DrawPoint(magnifierImg->getWidth() + 4, 0);
     }
 }
+#ifdef ANDROID
+bool dskGameInterface::simpleLeftClick(const MouseCoords& mc)
+{
+    DrawPoint btOrig(VIDEODRIVER.GetRenderSize().x / 2 - LOADER.GetImageN("resource", 29)->getWidth() / 2 + 44,
+                     VIDEODRIVER.GetRenderSize().y - LOADER.GetImageN("resource", 29)->getHeight() + 4);
+    Extent btSize = Extent(37, 32) * 4u;
+    if(IsPointInRect(mc.GetPos(), Rect(btOrig, btSize)))
+        return false;
+
+    // Start scrolling also on Ctrl + left click
+    if(VIDEODRIVER.GetModKeyState().ctrl)
+    {
+        Msg_RightDown(mc);
+        return true;
+    } else if(isScrolling)
+        StopScrolling();
+
+    // Unterscheiden je nachdem Straäcnbaumodus an oder aus ist
+    if(road.mode != RoadBuildMode::Disabled)
+    {
+        // in "richtige" Map-Koordinaten Konvertieren, den aktuellen selektierten Punkt
+        const MapPoint selPt = gwv.GetSelectedPt();
+
+        if(selPt == road.point)
+        {
+            // Selektierter Punkt ist der gleiche wie der Straßenpunkt --> Fenster mit Wegbau abbrechen
+            ShowRoadWindow(mc.GetPos());
+        } else
+        {
+            // altes Roadwindow schließen
+            WINDOWMANAGER.Close((unsigned)CGI_ROADWINDOW);
+
+            // Ist das ein gültiger neuer Wegpunkt?
+            if(worldViewer.IsRoadAvailable(road.mode == RoadBuildMode::Boat, selPt)
+               && worldViewer.IsPlayerTerritory(selPt))
+            {
+                MapPoint targetPt = selPt;
+                if(!BuildRoadPart(targetPt))
+                    ShowRoadWindow(mc.GetPos());
+            } else if(worldViewer.GetBQ(selPt) != BuildingQuality::Nothing)
+            {
+                // Wurde bereits auf das gebaute Stück geklickt?
+                unsigned idOnRoad = GetIdInCurBuildRoad(selPt);
+                if(idOnRoad)
+                    DemolishRoad(idOnRoad);
+                else
+                {
+                    MapPoint targetPt = selPt;
+                    if(BuildRoadPart(targetPt))
+                    {
+                        // Ist der Zielpunkt der gleiche geblieben?
+                        if(selPt == targetPt)
+                            GI_BuildRoad();
+                    } else if(selPt == targetPt)
+                        ShowRoadWindow(mc.GetPos());
+                }
+            }
+            // Wurde auf eine Flagge geklickt und ist diese Flagge nicht der Weganfangspunkt?
+            else if(worldViewer.GetWorld().GetNO(selPt)->GetType() == NodalObjectType::Flag && selPt != road.start)
+            {
+                MapPoint targetPt = selPt;
+                if(BuildRoadPart(targetPt))
+                {
+                    if(selPt == targetPt)
+                        GI_BuildRoad();
+                } else if(selPt == targetPt)
+                    ShowRoadWindow(mc.GetPos());
+            } else
+            {
+                unsigned tbr = GetIdInCurBuildRoad(selPt);
+                // Wurde bereits auf das gebaute Stück geklickt?
+                if(tbr)
+                    DemolishRoad(tbr);
+                else
+                    ShowRoadWindow(mc.GetPos());
+            }
+        }
+    } else
+    {
+        bool enable_military_buildings = false;
+
+        iwAction::Tabs action_tabs;
+
+        const MapPoint cSel = gwv.GetSelectedPt();
+
+        // Vielleicht steht hier auch ein Schiff?
+        if(const noShip* ship = worldViewer.GetShip(cSel))
+        {
+            WINDOWMANAGER.Show(std::make_unique<iwShip>(gwv, GAMECLIENT, ship));
+            return true;
+        }
+
+        // Evtl ists nen Haus? (unser Haus)
+        const noBase& selObj = *worldViewer.GetWorld().GetNO(cSel);
+        if(selObj.GetType() == NodalObjectType::Building && worldViewer.IsOwner(cSel))
+        {
+            if(auto* wnd = WINDOWMANAGER.FindNonModalWindow(CGI_BUILDING + MapBase::CreateGUIID(cSel)))
+            {
+                WINDOWMANAGER.SetActiveWindow(*wnd);
+                return true;
+            }
+            BuildingType bt = static_cast<const noBuilding&>(selObj).GetBuildingType();
+            // HQ
+            if(bt == BuildingType::Headquarters)
+                WINDOWMANAGER.Show(
+                  std::make_unique<iwHQ>(gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobHQ>(cSel)));
+            // Lagerhäuser
+            else if(bt == BuildingType::Storehouse)
+                WINDOWMANAGER.Show(std::make_unique<iwBaseWarehouse>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobStorehouse>(cSel)));
+            // Hafengebäude
+            else if(bt == BuildingType::HarborBuilding)
+                WINDOWMANAGER.Show(std::make_unique<iwHarborBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobHarborBuilding>(cSel)));
+            // Militärgebäude
+            else if(BuildingProperties::IsMilitary(bt))
+                WINDOWMANAGER.Show(std::make_unique<iwMilitaryBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobMilitary>(cSel)));
+            else if(bt == BuildingType::Temple)
+                WINDOWMANAGER.Show(std::make_unique<iwTempleBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobTemple>(cSel)));
+            else
+                WINDOWMANAGER.Show(std::make_unique<iwBuilding>(
+                  gwv, GAMECLIENT, worldViewer.GetWorldNonConst().GetSpecObj<nobUsual>(cSel)));
+            return true;
+        }
+        // oder vielleicht eine Baustelle?
+        else if(selObj.GetType() == NodalObjectType::Buildingsite && worldViewer.IsOwner(cSel))
+        {
+            if(!WINDOWMANAGER.FindNonModalWindow(CGI_BUILDING + MapBase::CreateGUIID(cSel)))
+                WINDOWMANAGER.Show(
+                  std::make_unique<iwBuildingSite>(gwv, worldViewer.GetWorld().GetSpecObj<noBuildingSite>(cSel)));
+            return true;
+        }
+
+        action_tabs.watch = true;
+        // Unser Land
+        if(worldViewer.IsOwner(cSel))
+        {
+            const BuildingQuality bq = worldViewer.GetBQ(cSel);
+            // Kann hier was gebaut werden?
+            if(bq >= BuildingQuality::Mine)
+            {
+                action_tabs.build = true;
+
+                // Welches Gebäude kann gebaut werden?
+                switch(bq)
+                {
+                    case BuildingQuality::Mine: action_tabs.build_tabs = iwAction::BuildTab::Mine; break;
+                    case BuildingQuality::Hut: action_tabs.build_tabs = iwAction::BuildTab::Hut; break;
+                    case BuildingQuality::House: action_tabs.build_tabs = iwAction::BuildTab::House; break;
+                    case BuildingQuality::Castle: action_tabs.build_tabs = iwAction::BuildTab::Castle; break;
+                    case BuildingQuality::Harbor: action_tabs.build_tabs = iwAction::BuildTab::Harbor; break;
+                    default: break;
+                }
+
+                if(!worldViewer.GetWorld().IsFlagAround(cSel))
+                    action_tabs.setflag = true;
+
+                // Prüfen, ob sich Militärgebäude in der Nähe befinden, wenn nein, können auch eigene
+                // Militärgebäude gebaut werden
+                enable_military_buildings =
+                  !worldViewer.GetWorld().IsMilitaryBuildingNearNode(cSel, worldViewer.GetPlayerId());
+            } else if(bq == BuildingQuality::Flag)
+                action_tabs.setflag = true;
+            else if(selObj.GetType() == NodalObjectType::Flag)
+                action_tabs.flag = true;
+
+            if(selObj.GetType() != NodalObjectType::Flag && selObj.GetType() != NodalObjectType::Building)
+            {
+                // Check if there are roads
+                for(const Direction dir : helpers::EnumRange<Direction>{})
+                {
+                    const PointRoad curRoad = worldViewer.GetVisiblePointRoad(cSel, dir);
+                    if(curRoad != PointRoad::None)
+                    {
+                        action_tabs.cutroad = true;
+                        action_tabs.upgradeRoad |= (curRoad == PointRoad::Normal);
+                    }
+                }
+            }
+        }
+        // evtl ists ein feindliches Militärgebäude, welches NICHT im Nebel liegt?
+        else if(worldViewer.GetVisibility(cSel) == Visibility::Visible)
+        {
+            if(selObj.GetType() == NodalObjectType::Building)
+            {
+                const auto* building = worldViewer.GetWorld().GetSpecObj<noBuilding>(cSel); //-V807
+                BuildingType bt = building->GetBuildingType();
+
+                // Only if trade is enabled
+                if(worldViewer.GetWorld().GetGGS().isEnabled(AddonId::TRADE))
+                {
+                    // Allied warehouse? -> Show trade window
+                    if(BuildingProperties::IsWareHouse(bt) && worldViewer.GetPlayer().IsAlly(building->GetPlayer()))
+                    {
+                        WINDOWMANAGER.Show(std::make_unique<iwTrade>(*static_cast<const nobBaseWarehouse*>(building),
+                                                                     worldViewer, GAMECLIENT));
+                        return true;
+                    }
+                }
+
+                // Ist es ein gewöhnliches Militärgebäude?
+                if(BuildingProperties::IsMilitary(bt))
+                {
+                    // Dann darf es nicht neu gebaut sein!
+                    if(!static_cast<const nobMilitary*>(building)->IsNewBuilt())
+                        action_tabs.attack = true;
+                }
+                // oder ein HQ oder Hafen?
+                else if(bt == BuildingType::Headquarters || bt == BuildingType::HarborBuilding)
+                    action_tabs.attack = true;
+                action_tabs.sea_attack =
+                  action_tabs.attack && worldViewer.GetWorld().GetGGS().isEnabled(AddonId::SEA_ATTACK);
+            }
+        }
+
+        // Bisheriges Actionfenster schließen, falls es eins gab
+        // aktuelle Mausposition merken, da diese durch das Schließen verändert werden kann
+        if(actionwindow)
+            actionwindow->Close();
+        VIDEODRIVER.SetMousePos(mc.GetPos());
+
+        ShowActionWindow(action_tabs, cSel, mc.GetPos(), enable_military_buildings);
+    }
+
+    return true;
+}
+
+bool dskGameInterface::Msg_LeftDown(const MouseCoords& mc)
+{
+    leftButtonDown = true;
+    leftDownStart = VIDEODRIVER.GetTickCount();
+     
+    if(mouseMove)
+    {
+        Msg_RightDown(mc);
+        return true;
+    } else if(isScrolling)
+        StopScrolling();
+    
+    //return simpleLeftClick(mc);
+    return true;
+}
+
+bool dskGameInterface::Msg_LeftUp(const MouseCoords& mc)
+{
+    leftButtonDown = false;
+    unsigned long leftDownDuration = VIDEODRIVER.GetTickCount() - leftDownStart;
+    
+    if(leftDownDuration < 125)
+	simpleLeftClick(mc);
+    
+    if(isScrolling)
+    {
+        StopScrolling();
+        return true;
+    }
+    return false;
+}
+#else
 
 bool dskGameInterface::Msg_LeftDown(const MouseCoords& mc)
 {
@@ -681,6 +944,7 @@
 
 bool dskGameInterface::Msg_LeftUp(const MouseCoords&)
 {
+    mouseMove = false;
     if(isScrolling)
     {
         StopScrolling();
@@ -688,9 +952,12 @@
     }
     return false;
 }
+#endif
 
 bool dskGameInterface::Msg_MouseMove(const MouseCoords& mc)
 {
+    mouseMove = true;
+    
     if(!isScrolling)
         return false;
 
@@ -698,9 +965,13 @@
 
     if(SETTINGS.interface.invertMouse)
         acceleration = -acceleration;
-
+    
+    #ifdef ANDROID
+    gwv.MoveBy((mc.GetPos() - startScrollPt) * acceleration);
+    #else
     gwv.MoveBy((mc.GetPos() - startScrollPt) * acceleration);
     VIDEODRIVER.SetMousePos(startScrollPt);
+    #endif
 
     if(!SETTINGS.global.smartCursor)
         startScrollPt = mc.GetPos();
@@ -917,7 +1188,7 @@
     return false;
 }
 
-bool dskGameInterface::Msg_WheelUp(const MouseCoords&)
+bool dskGameInterface::Msg_WheelUp(const MouseCoords&) //ANDROID ZOOM TESTING 
 {
     WheelZoom(ZOOM_WHEEL_INCREMENT);
     return true;
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/desktops/dskGameInterface.h s25client_patched/libs/s25main/desktops/dskGameInterface.h
--- s25client/libs/s25main/desktops/dskGameInterface.h	2024-09-29 22:16:56.647726357 +0200
+++ s25client_patched/libs/s25main/desktops/dskGameInterface.h	2024-10-01 20:01:12.531686000 +0200
@@ -117,6 +117,9 @@
     void Msg_PaintBefore() override;
     void Msg_PaintAfter() override;
     bool Msg_LeftDown(const MouseCoords& mc) override;
+    #ifdef ANDROID
+    bool simpleLeftClick(const MouseCoords& mc);
+    #endif
     bool Msg_LeftUp(const MouseCoords& mc) override;
     bool Msg_MouseMove(const MouseCoords& mc) override;
     bool Msg_RightDown(const MouseCoords& mc) override;
@@ -164,4 +167,10 @@
     bool isCheatModeOn;
     std::string curCheatTxt;
     Subscription evBld;
+    
+    #ifdef ANDROID
+    bool mouseMove;
+    bool leftButtonDown;
+    unsigned long leftDownStart;
+    #endif
 };
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/drivers/DriverWrapper.cpp s25client_patched/libs/s25main/drivers/DriverWrapper.cpp
--- s25client/libs/s25main/drivers/DriverWrapper.cpp	2024-09-29 22:16:56.651726453 +0200
+++ s25client_patched/libs/s25main/drivers/DriverWrapper.cpp	2024-09-29 22:25:02.411153000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "DriverWrapper.h"
 #include "ListDir.h"
@@ -44,17 +47,37 @@
 bool DriverWrapper::Load(const DriverType dt, std::string& preference)
 {
     // ggf. aufräumen vorher
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() unloading driver(if needed) "); //ANDROID
+    #endif
     Unload();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() driver unloaded "); //ANDROID
+    #endif
+
     /// Verfügbare Treiber auflisten
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() list drivers "); //ANDROID
+    #endif
     std::vector<DriverItem> drivers = LoadDriverList(dt);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() writing to log what drivers are found "); //ANDROID
+    #endif
     LOG.write("%u %s drivers found!\n") % drivers.size() % getName(dt);
 
     // Welche gefunden?
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() treiber gefunden? "); //ANDROID
+    #endif
     if(drivers.empty())
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::Load() Ja treiber gefunden "); //ANDROID
+    #endif
+
     /// Suche, ob der Treiber dabei ist, den wir wünschen
     const auto it = helpers::find_if(drivers, [preference](const auto& it) { return it.GetName() == preference; });
     if(it != drivers.end())
@@ -129,11 +152,22 @@
     return true;
 }
 
+
 std::vector<DriverWrapper::DriverItem> DriverWrapper::LoadDriverList(const DriverType dt)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers"); //ANDROID
+    #endif
     std::vector<DriverItem> driver_list;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers"); //ANDROID
+    #endif
+    #ifdef ANDROID
+    const bfs::path& driverDir = getenv("libDir") + getName(dt);
+    #else
     const auto driverDir = RTTRCONFIG.ExpandPath(s25::folders::driver) / getName(dt);
+    #endif
     std::string extension =
 #ifdef _WIN32
       "dll";
@@ -145,6 +179,9 @@
 #    endif // !__APPLE__
 #endif     // !_WIN32
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() searching for drivers in %s", driverDir.c_str()); //ANDROID
+    #endif
     LOG.write(_("Searching for drivers in %s\n")) % driverDir;
     const std::vector<boost::filesystem::path> driver_files = ListDir(driverDir, extension, false);
 
@@ -166,10 +203,21 @@
             continue;
 #endif
         std::string nameOrError;
+        #ifdef ANDROID
+        if(!CheckLibrary(path, dt, nameOrError)) {
+            LOG.write(_("Skipping %s: %s\n")) % path % nameOrError;
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() Skipping %s: %s",path.c_str(), nameOrError.c_str()); //ANDROID
+        }
+        else {
+            driver_list.push_back(DriverItem(path, nameOrError));
+             __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "DriverWrapper::LoadDriverList() error else %s", nameOrError.c_str()); //ANDROID
+        }
+        #else
         if(!CheckLibrary(path, dt, nameOrError))
             LOG.write(_("Skipping %s: %s\n")) % path % nameOrError;
         else
             driver_list.push_back(DriverItem(path, nameOrError));
+        #endif
     }
     return driver_list;
 }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/drivers/VideoDriverWrapper.cpp s25client_patched/libs/s25main/drivers/VideoDriverWrapper.cpp
--- s25client/libs/s25main/drivers/VideoDriverWrapper.cpp	2024-09-29 22:16:56.651726453 +0200
+++ s25client_patched/libs/s25main/drivers/VideoDriverWrapper.cpp	2024-09-29 22:25:02.411153000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2021 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "VideoDriverWrapper.h"
 #include "FrameCounter.h"
@@ -35,10 +38,18 @@
 
 VideoDriverWrapper::~VideoDriverWrapper()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::~VideoDriverWrapper()  cleanup"); //ANDROID
+    #endif
     CleanUp();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::~VideoDriverWrapper()  unload driver"); //ANDROID
+    #endif
     UnloadDriver();
 }
 
+void initialize_gl4es();
+
 bool VideoDriverWrapper::Initialize()
 {
     if(!videodriver || !videodriver->Initialize())
@@ -57,18 +68,36 @@
 
 bool VideoDriverWrapper::LoadDriver(IVideoDriver* existingDriver)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver() unloading driver"); //ANDROID
+    #endif
     UnloadDriver();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver() initialize ivideodriver"); //ANDROID
+    #endif
     videodriver = Handle(existingDriver, [](IVideoDriver* p) { delete p; });
     return Initialize();
 }
 
 bool VideoDriverWrapper::LoadDriver(std::string& preference)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() unload driver "); //ANDROID
+    #endif
     UnloadDriver();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() driver unloaded "); //ANDROID
+    #endif
     // DLL laden
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() load driver video "); //ANDROID
+    #endif
     if(!driver_wrapper.Load(drivers::DriverType::Video, preference))
         return false;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadDriver(anderer)() driver loaded "); //ANDROID
+    #endif
     auto createVideoInstance = driver_wrapper.GetFunction<CreateVideoInstance_t>("CreateVideoInstance");
     auto freeVideoInstance = driver_wrapper.GetFunction<FreeVideoInstance_t>("FreeVideoInstance");
     RTTR_Assert(createVideoInstance && freeVideoInstance);
@@ -96,32 +125,60 @@
 {
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
 
     if(!videodriver->CreateScreen(rttr::version::GetTitle(), size, fullscreen))
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Could not create window!"); //ANDROID
+        #endif
         s25util::fatal_error("Could not create window!");
         return false;
     }
-
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Window created"); //ANDROID
+    #endif
+
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen loading extensions"); //ANDROID
+    #endif
     // DriverWrapper Initialisieren
     // Extensions laden
     if(!LoadAllExtensions())
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen ERROR! failed to initialize the opengl context!"); //ANDROID
+        #endif
         s25util::fatal_error("Failed to initialize the OpenGL context!");
         return false;
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Renew Viewport..."); //ANDROID
+    #endif
     RenewViewport();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen Swapping buffers"); //ANDROID
+    #endif
     // Buffer swappen um den leeren Buffer darzustellen
     SwapBuffers();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen windowmanager msg screenresize(getrendersize())"); //ANDROID
+    #endif
     // WindowManager informieren
     WINDOWMANAGER.Msg_ScreenResize(GetRenderSize());
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::CreateScreen returning true"); //ANDROID
+    #endif
+
     return true;
 }
 
@@ -136,8 +193,15 @@
  */
 bool VideoDriverWrapper::ResizeScreen(const VideoMode size, const bool fullscreen)
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ResizeScreen"); //ANDROID
+    #endif
+    
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ResizeScreen No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
@@ -257,8 +321,14 @@
 
 void VideoDriverWrapper::SwapBuffers()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::SwapBuffers()"); //ANDROID
+    #endif
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR VideoDriverWrapper::SwapBuffers() No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return;
     }
@@ -271,17 +341,26 @@
 
 void VideoDriverWrapper::ClearScreen()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::ClearScreen"); //ANDROID
     glClear(GL_COLOR_BUFFER_BIT);
+    #endif
 }
 
 bool VideoDriverWrapper::Run()
 {
     if(!videodriver)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR VideoDriverWrapper::Run No video driver selected!"); //ANDROID
+        #endif
         s25util::fatal_error("No video driver selected!");
         return false;
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "INFO VideoDriverWrapper::Run returning videodriver->MessageLoop()"); //ANDROID
+    #endif
     return videodriver->MessageLoop();
 }
 
@@ -302,9 +381,15 @@
  */
 void VideoDriverWrapper::RenewViewport()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport"); //ANDROID
+    #endif
     if(!videodriver->IsOpenGL() || !renderer_)
         return;
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport is video driver not opengl"); //ANDROID
+    #endif
     const Extent renderSize = videodriver->GetRenderSize();
     const VideoMode windowSize = videodriver->GetWindowSize();
 
@@ -312,9 +397,18 @@
     glViewport(0, 0, windowSize.width, windowSize.height);
     glScissor(0, 0, windowSize.width, windowSize.height);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Orthogonale Matrix erstellen"); //ANDROID
+    #endif
     // Orthogonale Matrix erstellen
     glMatrixMode(GL_PROJECTION);
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport matrix mode"); //ANDROID
+    #endif
     glLoadIdentity();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport load identity"); //ANDROID
+    #endif
 
     // 0,0 should be top left corner
     glOrtho(0, renderSize.x, renderSize.y, 0, -100, 100);
@@ -322,6 +416,9 @@
     glMatrixMode(GL_MODELVIEW);
     glLoadIdentity();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Depthbuffer und Colorbuffer einstellen"); //ANDROID
+    #endif
     // Depthbuffer und Colorbuffer einstellen
     glClearColor(0.0, 0.0, 0.0, 1.0);
 
@@ -331,6 +428,9 @@
     glEnable(GL_ALPHA_TEST);
     glAlphaFunc(GL_GREATER, 0.0f);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Alphablending an"); //ANDROID
+    #endif
     // Alphablending an
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     glEnable(GL_BLEND);
@@ -348,12 +448,19 @@
     // Scissoring aktivieren
     glEnable(GL_SCISSOR_TEST);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport Nur obere Seite von Dreiecke rendern --> Performance"); //ANDROID
+    #endif
     // Nur obere Seite von Dreiecke rendern --> Performance
     glEnable(GL_CULL_FACE);
 
     glEnableClientState(GL_VERTEX_ARRAY);
     glEnableClientState(GL_TEXTURE_COORD_ARRAY);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::RenewViewport clearing screen"); //ANDROID
+    #endif
+
     ClearScreen();
 }
 
@@ -362,12 +469,38 @@
  */
 bool VideoDriverWrapper::LoadAllExtensions()
 {
+    #ifdef ANDROID
+    if(videodriver->IsOpenGL()) {
+        renderer_ = std::make_unique<OpenGLRenderer>();
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL wrapper"); //ANDROID
+    }
+    else{
+        renderer_ = std::make_unique<DummyRenderer>();
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions dummy wrapper"); //ANDROID
+    }
+    if(!renderer_->initOpenGL(videodriver->GetLoaderFunction())) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions renderer is not initopengl! error"); //ANDROID
+        return false;
+    }
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL supported!"); //ANDROID
+    LOG.write(_("OpenGL %1%.%2% supported\n")) % GLVersion.major % GLVersion.minor;
+    if(GLVersion.major < RTTR_OGL_MAJOR || (GLVersion.major == RTTR_OGL_MAJOR && GLVersion.minor < RTTR_OGL_MINOR))
+    {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions OpenGL not supported try updating gpu drivers"); //ANDROID
+        LOG.write(_("OpenGL %1% %2%.%3% is not supported. Try updating your GPU drivers or hardware!"))
+          % ((RTTR_OGL_ES) ? "ES" : "") % RTTR_OGL_MAJOR % RTTR_OGL_MINOR;
+        return false;
+    }
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions auf vsync testen"); //ANDROID
+    #else
     if(videodriver->IsOpenGL())
         renderer_ = std::make_unique<OpenGLRenderer>();
     else
         renderer_ = std::make_unique<DummyRenderer>();
+    
     if(!renderer_->initOpenGL(videodriver->GetLoaderFunction()))
         return false;
+        
     LOG.write(_("OpenGL %1%.%2% supported\n")) % GLVersion.major % GLVersion.minor;
     if(GLVersion.major < RTTR_OGL_MAJOR || (GLVersion.major == RTTR_OGL_MAJOR && GLVersion.minor < RTTR_OGL_MINOR))
     {
@@ -375,6 +508,7 @@
           % ((RTTR_OGL_ES) ? "ES" : "") % RTTR_OGL_MAJOR % RTTR_OGL_MINOR;
         return false;
     }
+    #endif
 
 // auf VSync-Extension testen
 #ifdef _WIN32
@@ -383,6 +517,9 @@
     wglSwapIntervalEXT = reinterpret_cast<SwapIntervalExt_t*>(loadExtension("glXSwapIntervalSGI"));
 #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "VideoDriverWrapper::LoadAllExtensions returning true"); //ANDROID
+    #endif
     return true;
 }
 
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/network/GameClient.cpp s25client_patched/libs/s25main/network/GameClient.cpp
--- s25client/libs/s25main/network/GameClient.cpp	2024-09-29 22:16:56.667726843 +0200
+++ s25client_patched/libs/s25main/network/GameClient.cpp	2024-09-29 22:25:02.411153000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "GameClient.h"
 #include "CreateServerInfo.h"
@@ -149,50 +152,94 @@
  */
 void GameClient::Run()
 {
+    #ifdef ANDROID
+    if(state == ClientState::Stopped) {
+         __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run clientstate is stopped returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ClientState::Stopped)
         return;
+    #endif
 
     SocketSet set;
 
     // erstmal auf Daten überprüfen
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run clear socketset"); //ANDROID
+    #endif
     set.Clear();
 
     // zum set hinzufügen
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run adding mainplayer to socket"); //ANDROID
+    #endif
     set.Add(mainPlayer.socket);
     if(set.Select(0, 0) > 0)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run mainplayer empfangen?"); //ANDROID
+        #endif
         // nachricht empfangen
         if(!mainPlayer.receiveMsgs())
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR GameClient::Run receiving message from server failed"); //ANDROID
+            #endif
             LOG.write("Receiving Message from server failed\n");
             ServerLost();
         }
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run suche nach fehlern"); //ANDROID
+    #endif
     // nun auf Fehler prüfen
     set.Clear();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run player zum socket hizufügen(wieder)"); //ANDROID
+    #endif
     // zum set hinzufügen
     set.Add(mainPlayer.socket);
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run suche nach fehlern(2)"); //ANDROID
+    #endif
     // auf fehler prüfen
     if(set.Select(0, 2) > 0)
     {
         if(set.InSet(mainPlayer.socket))
         {
+            #ifdef ANDROID
+            __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run Server weg(lost)"); //ANDROID
+            #endif
             // Server ist weg
             LOG.write("Error on socket to server\n");
             ServerLost();
         }
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run ist cflient loaded?"); //ANDROID
+    #endif
     if(state == ClientState::Loaded)
     {
+        #ifdef ANDROID
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run yes"); //ANDROID
+        #endif
         // All players ready?
         if(nwfInfo->isReady())
             OnGameStart();
+    #ifdef ANDROID
+    } else if(state == ClientState::Game){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run executing game frame"); //ANDROID
+        ExecuteGameFrame();
+    }
+    #else
     } else if(state == ClientState::Game)
         ExecuteGameFrame();
+    #endif
 
     // maximal 10 Pakete verschicken
     mainPlayer.sendMsgs(10);
@@ -205,8 +252,16 @@
  */
 void GameClient::Stop()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Stop"); //ANDROID
+    if(state == ClientState::Stopped) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Stop client stopped. returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ClientState::Stopped)
         return;
+    #endif
 
     if(game)
         ExitGame();
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/network/GameServer.cpp s25client_patched/libs/s25main/network/GameServer.cpp
--- s25client/libs/s25main/network/GameServer.cpp	2024-09-29 22:16:56.667726843 +0200
+++ s25client_patched/libs/s25main/network/GameServer.cpp	2024-09-29 22:25:02.411153000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "GameServer.h"
 #include "Debug.h"
@@ -277,8 +280,15 @@
 // Hauptschleife
 void GameServer::Run()
 {
+    #ifdef ANDROID
+    if(state == ServerState::Stopped) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "GameClient::Run serverstate is stopped returning"); //ANDROID
+        return;
+    }
+    #else
     if(state == ServerState::Stopped)
         return;
+    #endif
 
     // auf tote Clients prüfen
     ClientWatchDog();
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Settings.cpp s25client_patched/libs/s25main/Settings.cpp
--- s25client/libs/s25main/Settings.cpp	2024-09-29 22:16:56.635726066 +0200
+++ s25client_patched/libs/s25main/Settings.cpp	2024-09-29 23:08:12.456750000 +0200
@@ -73,7 +73,11 @@
     // 0 = ask user at start, 1 = enabled, 2 = always ask
     global.submit_debug_data = 0;
     global.use_upnp = false;
+    #ifdef ANDROID
+    global.smartCursor = false;
+    #else
     global.smartCursor = true;
+    #endif
     global.debugMode = false;
     global.showGFInfo = false;
     // }
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/Window.cpp s25client_patched/libs/s25main/Window.cpp
--- s25client/libs/s25main/Window.cpp	2024-09-29 22:16:56.639726162 +0200
+++ s25client_patched/libs/s25main/Window.cpp	2024-09-29 22:25:02.415153000 +0200
@@ -1,6 +1,9 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#endif
 
 #include "Window.h"
 #include "CollisionDetection.h"
@@ -35,8 +38,16 @@
  */
 void Window::Draw()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::draw() is visible?"); //ANDROID
+    if(visible_) {
+         __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::draw() yes drawing window draw_"); //ANDROID
+        Draw_();
+    }
+    #else
     if(visible_)
         Draw_();
+    #endif
 }
 
 DrawPoint Window::GetPos() const
@@ -513,8 +524,16 @@
 
 void Window::Draw_()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::Draw_"); //ANDROID
+    for(Window* control : childIdToWnd_ | boost::adaptors::map_values) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "Window::Draw_ control->Draw()"); //ANDROID
+        control->Draw();
+    }
+    #else
     for(Window* control : childIdToWnd_ | boost::adaptors::map_values)
         control->Draw();
+    #endif
 }
 
 void Window::Msg_ScreenResize(const ScreenResizeEvent& sr)
diff -ruN --binary -x '.*' -x patched s25client/libs/s25main/WindowManager.cpp s25client_patched/libs/s25main/WindowManager.cpp
--- s25client/libs/s25main/WindowManager.cpp	2024-09-29 22:16:56.639726162 +0200
+++ s25client_patched/libs/s25main/WindowManager.cpp	2024-09-29 22:25:02.415153000 +0200
@@ -1,6 +1,11 @@
 // Copyright (C) 2005 - 2024 Settlers Freaks (sf-team at siedler25.org)
 //
 // SPDX-License-Identifier: GPL-2.0-or-later
+#ifdef ANDROID
+#include <android/log.h>
+#include <sstream>
+#include <string>
+#endif
 
 #include "WindowManager.h"
 #include "CollisionDetection.h"
@@ -64,19 +69,60 @@
  */
 void WindowManager::Draw()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw"); //ANDROID
+    #endif
+    
+    #ifdef ANDROID
     // ist ein neuer Desktop eingetragen? Wenn ja, wechseln
-    if(nextdesktop)
+    if(nextdesktop){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw switching desktop"); //ANDROID
         DoDesktopSwitch();
+    }
+    #else
+    if(nextdesktop)
+    DoDesktopSwitch();
+    #endif
+
+    #ifdef ANDROID
+    std::ostringstream oss;
+    oss << curDesktop.get();
+    std::string pointerStr = oss.str();
+    
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw curdesktop: %s", pointerStr.c_str()); //ANDROID
+    #endif
 
+    #ifdef ANDROID
+    if(!curDesktop) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw not desktop return"); //ANDROID
+        return;
+    }
+    #else
     if(!curDesktop)
         return;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw msg paintBefore() to desktop"); //ANDROID
+    #endif
     curDesktop->Msg_PaintBefore();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw desktop draw"); //ANDROID  ABSTURZ HIER!!!!!!!!!!!! fixed
+    #endif
     curDesktop->Draw();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw msg painAfter() to desktop"); //ANDROID
+    #endif
     curDesktop->Msg_PaintAfter();
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw close marked windows"); //ANDROID
+    #endif
     // First close all marked windows
     CloseMarkedIngameWnds();
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw done closing marked windows"); //ANDROID
+    #endif
     for(auto& wnd : windows)
     {
         // If the window is not minimized, call paintAfter
@@ -88,8 +134,14 @@
             wnd->Msg_PaintAfter();
     }
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw drawtooltip"); //ANDROID
     DrawToolTip();
+    #endif
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::Draw drawcursor"); //ANDROID
     DrawCursor();
+    #endif
 }
 
 /**
@@ -100,8 +152,18 @@
  */
 bool WindowManager::IsDesktopActive()
 {
+    #ifdef ANDROID
+    if(curDesktop){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "INFO WindowManager::IsDesktopActive() desktop is active"); //ANDROID
+        return curDesktop->IsActive();
+    }
+    #else
     if(curDesktop)
         return curDesktop->IsActive();
+    #endif
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "ERROR WindowManager::Draw desktop not active"); //ANDROID
+    #endif
 
     return false;
 }
@@ -713,28 +775,67 @@
  */
 void WindowManager::DoDesktopSwitch()
 {
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch()"); //ANDROID
+    #endif
     RTTR_Assert(nextdesktop);
     VIDEODRIVER.ClearScreen();
 
     SetToolTip(nullptr, "");
 
     // If we have a current desktop close all windows
+    #ifdef ANDROID
+    if(curDesktop){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() closing all windows cause of current desktop"); //ANDROID
+        windows.clear();
+    }
+    #else
     if(curDesktop)
         windows.clear();
+    #endif
 
     // Do the switch
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() do the desktop switch. move nextdesktop"); //ANDROID
+    #endif
     curDesktop = std::move(nextdesktop);
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() desktop -> set active(true)"); //ANDROID
+    #endif
     curDesktop->SetActive(true);
 
+    #ifdef ANDROID
+    for(auto& nextWnd : nextWnds){
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() show next window"); //ANDROID
+        Show(std::move(nextWnd));
+    }
+    #else
     for(auto& nextWnd : nextWnds)
         Show(std::move(nextWnd));
+    #endif
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() clear next window"); //ANDROID
+    #endif
     nextWnds.clear();
 
+    #ifdef ANDROID
+    if(!VIDEODRIVER.IsLeftDown()) {
+        __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() enable mouse"); //ANDROID
+        disable_mouse = false;
+    }
+    #else
     if(!VIDEODRIVER.IsLeftDown())
         disable_mouse = false;
+    #endif
 
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() dummy mouse"); //ANDROID
+    #endif
     // Dummy mouse move to init hovering etc
     Msg_MouseMove(MouseCoords(VIDEODRIVER.GetMousePos()));
+    #ifdef ANDROID
+    __android_log_print(ANDROID_LOG_DEBUG, "org.libsdl.app", "WindowManager::DoDesktopSwitch() returning"); //ANDROID
+    #endif
 }
 
 void WindowManager::CloseMarkedIngameWnds()
